<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Universe Map</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; color: #ccc; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  canvas { display: block; }

  /* UI Panels */
  .panel {
    position: absolute;
    background: rgba(10, 15, 30, 0.92);
    border: 1px solid rgba(100, 140, 255, 0.3);
    border-radius: 8px;
    padding: 16px;
    backdrop-filter: blur(6px);
  }
  .panel h3 {
    color: #7ab4ff;
    margin-bottom: 10px;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .panel label {
    display: block;
    font-size: 12px;
    color: #8899bb;
    margin-bottom: 3px;
    margin-top: 8px;
  }
  .panel input[type="text"],
  .panel input[type="number"],
  .panel select {
    width: 100%;
    padding: 6px 8px;
    background: rgba(20, 30, 60, 0.8);
    border: 1px solid rgba(100, 140, 255, 0.25);
    border-radius: 4px;
    color: #ddeeff;
    font-size: 13px;
    outline: none;
  }
  .panel select { cursor: pointer; }
  .panel select option { background: #0a0f1e; color: #ddeeff; }
  .panel input:focus, .panel select:focus {
    border-color: rgba(100, 140, 255, 0.6);
  }
  .btn {
    display: inline-block;
    padding: 7px 14px;
    margin-top: 10px;
    margin-right: 4px;
    background: rgba(60, 100, 220, 0.3);
    border: 1px solid rgba(100, 140, 255, 0.4);
    border-radius: 4px;
    color: #aaccff;
    font-size: 12px;
    cursor: pointer;
    transition: background 0.2s;
  }
  .btn:hover { background: rgba(60, 100, 220, 0.55); }
  .btn.active { background: rgba(60, 100, 220, 0.6); border-color: #7ab4ff; color: #fff; }
  .btn.danger { background: rgba(200, 50, 50, 0.3); border-color: rgba(255, 80, 80, 0.4); color: #ffaaaa; }
  .btn.danger:hover { background: rgba(200, 50, 50, 0.55); }

  /* Collapsible panels */
  .panel-toggle {
    cursor: pointer;
    user-select: none;
  }
  .panel-toggle::before {
    content: '\25BE '; /* ▾ down arrow */
    font-size: 10px;
    margin-right: 4px;
  }
  .panel-toggle.collapsed::before {
    content: '\25B8 '; /* ▸ right arrow */
  }
  .panel-body.collapsed {
    display: none !important;
  }

  /* Left panel stack */
  #left-panel-stack {
    position: absolute;
    top: 16px;
    left: 16px;
    width: 260px;
    max-height: calc(100vh - 32px);
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow-y: auto;
    pointer-events: none;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,140,255,0.3) transparent;
  }
  #left-panel-stack > .panel {
    pointer-events: auto;
    position: relative;
    width: 100%;
  }

  /* Add Star Panel */
  .coord-row {
    display: flex;
    gap: 6px;
  }
  .coord-row > div { flex: 1; }

  /* Tools Panel */
  #tools-panel {
    top: 16px;
    right: 16px;
    width: 240px;
  }
  #distance-result {
    margin-top: 10px;
    padding: 8px;
    background: rgba(20, 30, 60, 0.6);
    border-radius: 4px;
    font-size: 13px;
    min-height: 20px;
    display: none;
  }
  #distance-result.visible { display: block; }

  /* Zones Panel */
  #zones-panel {
    max-height: 350px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  #zone-list {
    overflow-y: auto;
    flex: 1;
    max-height: 180px;
  }
  .zone-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 6px;
    border-radius: 3px;
    font-size: 12px;
    cursor: default;
    transition: background 0.15s;
  }
  .zone-entry:hover { background: rgba(60, 100, 220, 0.15); }
  .zone-entry .zone-color-dot {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: middle;
  }
  .zone-entry .zone-name { color: #ddeeff; }
  .zone-entry .zone-star-count { color: #667799; font-size: 11px; margin-left: 6px; }
  .zone-entry .delete-zone {
    color: #ff6666;
    cursor: pointer;
    font-size: 14px;
    padding: 0 4px;
    opacity: 0;
    transition: opacity 0.15s;
  }
  .zone-entry:hover .delete-zone { opacity: 1; }
  .zone-entry .toggle-zone {
    cursor: pointer;
    font-size: 13px;
    padding: 0 4px;
    color: #88aacc;
    opacity: 0.6;
    transition: opacity 0.15s;
  }
  .zone-entry .toggle-zone:hover { opacity: 1; }
  .zone-entry .toggle-zone.hidden { color: #556677; }
  .zone-entry.zone-hidden .zone-name,
  .zone-entry.zone-hidden .zone-star-count { opacity: 0.4; }

  /* Context Menus */
  #star-context-menu, #multi-context-menu {
    position: absolute;
    display: none;
    background: rgba(10, 15, 30, 0.97);
    border: 1px solid rgba(100, 140, 255, 0.4);
    border-radius: 6px;
    padding: 4px 0;
    z-index: 150;
    min-width: 160px;
    backdrop-filter: blur(6px);
  }
  .ctx-item {
    padding: 7px 14px;
    font-size: 13px;
    color: #ddeeff;
    cursor: pointer;
    transition: background 0.1s;
  }
  .ctx-item:hover { background: rgba(60, 100, 220, 0.3); }
  .ctx-danger { color: #ff6666; }
  .ctx-danger:hover { background: rgba(200, 50, 50, 0.3); }
  .ctx-zone-option {
    padding: 5px 14px;
    font-size: 12px;
    color: #ddeeff;
    cursor: pointer;
    transition: background 0.1s;
  }
  .ctx-zone-option:hover { background: rgba(60, 100, 220, 0.3); }

  /* Star Info Tooltip */
  #star-tooltip {
    position: absolute;
    display: none;
    background: rgba(10, 15, 30, 0.95);
    border: 1px solid rgba(100, 140, 255, 0.4);
    border-radius: 6px;
    padding: 10px 14px;
    pointer-events: none;
    font-size: 13px;
    max-width: 250px;
    z-index: 100;
  }
  #star-tooltip .star-name {
    color: #7ab4ff;
    font-weight: bold;
    font-size: 14px;
    margin-bottom: 4px;
  }
  #star-tooltip .star-coords { color: #88aacc; }
  #star-tooltip .star-zone { color: #99aa77; font-size: 12px; margin-top: 2px; }

  /* Star List */
  #star-list-panel {
    max-height: 250px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  #star-list-body {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    flex: 1;
    min-height: 0;
  }
  #star-list {
    overflow-y: auto;
    flex: 1;
  }
  .star-folder {
    margin-bottom: 2px;
  }
  .star-folder-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 6px;
    border-radius: 3px;
    font-size: 12px;
    cursor: pointer;
    color: #7ab4ff;
    transition: background 0.15s;
  }
  .star-folder-header:hover { background: rgba(60, 100, 220, 0.15); }
  .star-folder-header .folder-toggle { margin-right: 4px; font-size: 10px; }
  .star-folder-header .folder-count { color: #667799; font-size: 11px; margin-left: 4px; }
  .star-folder-header .delete-folder {
    color: #ff6666; cursor: pointer; font-size: 14px; padding: 0 4px;
    opacity: 0; transition: opacity 0.15s;
  }
  .star-folder-header:hover .delete-folder { opacity: 1; }
  .star-folder-contents {
    padding-left: 12px;
  }
  .star-folder-contents.collapsed { display: none; }
  #star-search {
    flex-shrink: 0;
    width: 100%;
    padding: 5px 8px;
    margin-top: 6px;
    background: rgba(20, 30, 60, 0.8);
    border: 1px solid rgba(100, 140, 255, 0.25);
    border-radius: 4px;
    color: #ddeeff;
    font-size: 12px;
    outline: none;
    box-sizing: border-box;
  }
  #star-search:focus { border-color: rgba(100, 140, 255, 0.6); }
  #star-search::placeholder { color: #556688; }
  #star-list-toolbar {
    display: flex;
    gap: 4px;
    margin-bottom: 6px;
    flex-shrink: 0;
  }
  #star-list-toolbar .btn { font-size: 10px; padding: 3px 8px; }
  #move-to-folder-select {
    font-size: 10px;
    padding: 2px 4px;
    background: rgba(30, 50, 100, 0.5);
    color: #aabbdd;
    border: 1px solid rgba(100, 140, 255, 0.2);
    border-radius: 3px;
    cursor: pointer;
    max-width: 120px;
  }
  .star-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 6px;
    border-radius: 3px;
    font-size: 12px;
    cursor: pointer;
    transition: background 0.15s;
  }
  .star-entry:hover { background: rgba(60, 100, 220, 0.2); }
  .star-entry.selected { background: rgba(60, 100, 220, 0.35); }
  .star-entry .name { color: #ddeeff; }
  .star-entry .coords { color: #667799; font-size: 11px; }
  .star-entry .star-zone-tag {
    font-size: 10px;
    padding: 1px 5px;
    border-radius: 3px;
    color: #fff;
    opacity: 0.7;
  }
  .star-entry .delete-star {
    color: #ff6666;
    cursor: pointer;
    font-size: 14px;
    padding: 0 4px;
    opacity: 0;
    transition: opacity 0.15s;
  }
  .star-entry:hover .delete-star { opacity: 1; }

  /* Edit Solar System Modal */
  #solar-system-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 200;
    justify-content: center;
    align-items: center;
  }
  #solar-system-overlay.visible { display: flex; }
  #solar-system-popup {
    position: relative;
    background: rgba(10, 15, 30, 0.97);
    border: 1px solid rgba(100, 140, 255, 0.4);
    border-radius: 10px;
    padding: 24px;
    width: 610px;
    backdrop-filter: blur(10px);
  }
  #solar-system-popup h3 {
    margin: 0 0 12px 0;
    color: #7ab4ff;
    font-size: 16px;
  }
  #solar-system-canvas {
    display: block;
    width: 560px;
    height: 480px;
    background: rgba(5, 8, 18, 0.8);
    border-radius: 6px;
    border: 1px solid rgba(100, 140, 255, 0.15);
  }
  #solar-system-close {
    position: absolute;
    top: 12px;
    right: 16px;
    color: #ff6666;
    font-size: 22px;
    cursor: pointer;
    line-height: 1;
  }
  #solar-system-close:hover { color: #ff9999; }
  #solar-system-popup .btn-row-bottom {
    position: absolute;
    bottom: 28px;
    right: 28px;
    display: flex;
    gap: 8px;
  }

  #bulk-add-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 300;
    justify-content: center;
    align-items: center;
  }
  #bulk-add-overlay.visible { display: flex; }

  #edit-overlay, #edit-zone-overlay, #edit-planet-overlay, #add-planet-overlay, #add-moon-overlay, #edit-moon-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 300;
    justify-content: center;
    align-items: center;
  }
  #edit-overlay.visible, #edit-zone-overlay.visible, #edit-planet-overlay.visible, #add-planet-overlay.visible, #add-moon-overlay.visible, #edit-moon-overlay.visible { display: flex; }
  #edit-modal {
    background: rgba(10, 15, 30, 0.97);
    border: 1px solid rgba(100, 140, 255, 0.4);
    border-radius: 10px;
    padding: 24px;
    width: 300px;
    max-height: 90vh;
    overflow-y: auto;
    backdrop-filter: blur(10px);
  }
  #edit-modal h3 {
    color: #7ab4ff;
    margin-bottom: 12px;
    font-size: 15px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  #edit-modal label {
    display: block;
    font-size: 12px;
    color: #8899bb;
    margin-bottom: 3px;
    margin-top: 10px;
  }
  #edit-modal input[type="text"],
  #edit-modal input[type="number"],
  #edit-modal select {
    width: 100%;
    padding: 7px 9px;
    background: rgba(20, 30, 60, 0.8);
    border: 1px solid rgba(100, 140, 255, 0.25);
    border-radius: 4px;
    color: #ddeeff;
    font-size: 13px;
    outline: none;
  }
  #edit-modal select { cursor: pointer; }
  #edit-modal select option { background: #0a0f1e; color: #ddeeff; }
  #edit-modal input:focus, #edit-modal select:focus {
    border-color: rgba(100, 140, 255, 0.6);
  }
  #edit-modal .edit-coord-row { display: flex; gap: 6px; }
  #edit-modal .edit-coord-row > div { flex: 1; }
  .zone-star-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 6px;
    border-radius: 3px;
    font-size: 12px;
    color: #ddeeff;
  }
  .zone-star-entry:hover { background: rgba(60, 100, 220, 0.15); }
  .zone-star-entry .remove-from-zone {
    color: #ff6666;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 6px;
    border: 1px solid rgba(255, 80, 80, 0.3);
    border-radius: 3px;
    background: rgba(200, 50, 50, 0.15);
  }
  .zone-star-entry .remove-from-zone:hover { background: rgba(200, 50, 50, 0.35); }
  .zone-star-empty, .planet-list-empty, .moon-list-empty { color: #667799; font-size: 12px; font-style: italic; padding: 4px 6px; }
  .moon-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 6px;
    border-radius: 3px;
    font-size: 12px;
    color: #ddeeff;
  }
  .moon-entry:hover { background: rgba(60, 100, 220, 0.15); }
  .moon-entry .remove-moon {
    color: #ff6666;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 6px;
    border: 1px solid rgba(255, 80, 80, 0.3);
    border-radius: 3px;
    background: rgba(200, 50, 50, 0.15);
  }
  .moon-entry .remove-moon:hover { background: rgba(200, 50, 50, 0.35); }
  .planet-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 6px;
    border-radius: 3px;
    font-size: 12px;
    color: #ddeeff;
  }
  .planet-entry:hover { background: rgba(60, 100, 220, 0.15); }
  .planet-entry .planet-class-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
    vertical-align: middle;
  }
  .planet-entry .remove-planet {
    color: #ff6666;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 6px;
    border: 1px solid rgba(255, 80, 80, 0.3);
    border-radius: 3px;
    background: rgba(200, 50, 50, 0.15);
  }
  .planet-entry .remove-planet:hover { background: rgba(200, 50, 50, 0.35); }
  #edit-modal .btn-row { margin-top: 16px; display: flex; gap: 8px; }
  #edit-modal .btn-row .btn { flex: 1; text-align: center; }

  /* File input hidden */
  #file-input { display: none; }

  /* Instructions */
  #instructions {
    position: absolute;
    bottom: 16px;
    right: 16px;
    background: rgba(10, 15, 30, 0.85);
    border: 1px solid rgba(100, 140, 255, 0.2);
    border-radius: 8px;
    padding: 12px 16px;
    font-size: 11px;
    color: #667799;
    line-height: 1.6;
  }
  /* Size slider groups */
  .size-slider-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .size-slider-group input[type="range"] {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    background: rgba(20, 30, 60, 0.8);
    border: 1px solid rgba(100, 140, 255, 0.25);
    border-radius: 3px;
    outline: none;
  }
  .size-slider-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #7ab4ff;
    cursor: pointer;
    border: none;
  }
  .size-slider-group input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #7ab4ff;
    cursor: pointer;
    border: none;
  }
  .size-slider-group .size-value {
    min-width: 80px;
    text-align: right;
    font-size: 11px;
    color: #aaccff;
    font-family: monospace;
    white-space: nowrap;
  }

  /* Selection box overlay */
  #select-box {
    position: fixed;
    border: 1px solid #7ab4ff;
    background: rgba(60,100,220,0.15);
    pointer-events: none;
    display: none;
    z-index: 9999;
  }
</style>
</head>
<body>
<div id="select-box"></div>

<!-- Add Star Panel -->
<div id="left-panel-stack">

<div id="add-panel" class="panel">
  <h3 class="panel-toggle" data-target="add-panel-body">Add Star</h3>
  <div id="add-panel-body" class="panel-body">
  <label for="star-name">Name</label>
  <input type="text" id="star-name" placeholder="optional (auto-numbered)">
  <div class="coord-row">
    <div>
      <label for="star-x">X (ly)</label>
      <input type="number" id="star-x" placeholder="0" min="0" max="1000" step="any">
    </div>
    <div>
      <label for="star-y">Y (ly)</label>
      <input type="number" id="star-y" placeholder="0" min="0" max="1000" step="any">
    </div>
    <div>
      <label for="star-z">Z (ly)</label>
      <input type="number" id="star-z" placeholder="0" min="0" max="1000" step="any">
    </div>
  </div>
  <label for="star-zone">Zone (optional)</label>
  <select id="star-zone"><option value="">None</option></select>
  <button class="btn" id="btn-add-star">Add Star</button>
  <button class="btn" id="btn-bulk-add" style="margin-top:6px; width:100%; font-size:11px;">Bulk Add Stars</button>
  </div>
</div>

<!-- Zones Panel -->
<div id="zones-panel" class="panel">
  <h3 class="panel-toggle" data-target="zones-panel-body">Zones</h3>
  <div id="zones-panel-body" class="panel-body">
  <label for="zone-name">Name</label>
  <input type="text" id="zone-name" placeholder="e.g. Federation Space">
  <label for="zone-color">Color</label>
  <select id="zone-color">
    <option value="red">Red</option>
    <option value="blue">Blue</option>
    <option value="yellow">Yellow</option>
    <option value="green">Green</option>
    <option value="gray">Gray</option>
  </select>
  <button class="btn" id="btn-add-zone">Add Zone</button>
  <hr style="border:none; border-top:1px solid rgba(100,140,255,0.15); margin:12px 0 8px;">
  <div id="zone-list"></div>
  </div>
</div>

<!-- Star List -->
<div id="star-list-panel" class="panel">
  <h3 class="panel-toggle" data-target="star-list-body">Stars (<span id="star-count">0</span>)</h3>
  <div id="star-list-body" class="panel-body">
  <div id="star-list-toolbar">
    <button class="btn" id="btn-add-folder">+ Folder</button>
    <select id="move-to-folder-select" title="Move selected stars to a folder">
      <option value="" disabled selected>Move to...</option>
    </select>
  </div>
  <div id="star-list"></div>
  <input type="text" id="star-search" placeholder="Search stars..." autocomplete="off">
  </div>
</div>

</div><!-- /left-panel-stack -->

<!-- Tools Panel -->
<div id="tools-panel" class="panel">
  <h3 class="panel-toggle" data-target="tools-panel-body">Tools</h3>
  <div id="tools-panel-body" class="panel-body">
  <button class="btn" id="btn-unit-toggle">Units: ly</button>
  <hr style="border:none; border-top:1px solid rgba(100,140,255,0.15); margin:10px 0 8px;">
  <button class="btn" id="btn-measure">Measure Distance</button>
  <button class="btn" id="btn-cancel-measure" style="display:none;">Cancel</button>
  <div id="measure-instructions" style="display:none; margin-top:8px; font-size:12px; color:#88aacc;">
    Click two stars or planets to measure the distance between them.
  </div>
  <div id="distance-result">
    <span id="distance-text"></span>
  </div>
  <hr style="border:none; border-top:1px solid rgba(100,140,255,0.15); margin:14px 0 10px;">
  <h3>Data</h3>
  <button class="btn" id="btn-export">Export JSON</button>
  <button class="btn" id="btn-import">Import JSON</button>
  <button class="btn danger" id="btn-clear-all">Clear All</button>
  <input type="file" id="file-input" accept=".json">
  </div>
</div>

<!-- Star Tooltip -->
<div id="star-tooltip">
  <div class="star-name" id="tooltip-name"></div>
  <div class="star-coords" id="tooltip-coords"></div>
  <div class="star-zone" id="tooltip-zone"></div>
</div>

<!-- Star Context Menu -->
<div id="star-context-menu">
  <div class="ctx-item" id="ctx-view-system">View System</div>
  <div class="ctx-item ctx-danger" id="ctx-delete-star">Delete Star</div>
</div>

<div id="multi-context-menu">
  <div class="ctx-item" id="ctx-multi-add-zone">Add to Zone</div>
  <div id="ctx-zone-submenu" style="display:none; padding:2px 0 2px 10px;"></div>
  <div class="ctx-item ctx-danger" id="ctx-multi-delete">Delete Selected Stars</div>
</div>

<!-- Edit Solar System Modal -->
<div id="edit-overlay">
  <div id="edit-modal">
    <h3>Edit Solar System</h3>
    <input type="hidden" id="edit-star-id">
    <label for="edit-star-name">Name</label>
    <input type="text" id="edit-star-name">
    <div class="edit-coord-row">
      <div>
        <label for="edit-star-x">X (ly)</label>
        <input type="number" id="edit-star-x" min="0" max="1000" step="any">
      </div>
      <div>
        <label for="edit-star-y">Y (ly)</label>
        <input type="number" id="edit-star-y" min="0" max="1000" step="any">
      </div>
      <div>
        <label for="edit-star-z">Z (ly)</label>
        <input type="number" id="edit-star-z" min="0" max="1000" step="any">
      </div>
    </div>
    <label for="edit-star-size">Size / Radius (AU)</label>
    <div class="size-slider-group">
      <input type="range" id="edit-star-size" min="-3" max="0" step="0.01">
      <span class="size-value" id="edit-star-size-value">0.00465 AU</span>
    </div>
    <label>Zones</label>
    <div id="edit-star-zones" style="max-height:80px; overflow-y:auto; margin-top:4px;"></div>
    <label for="edit-star-folder">Folder</label>
    <select id="edit-star-folder"><option value="">None</option></select>
    <hr style="border:none; border-top:1px solid rgba(100,140,255,0.15); margin:12px 0 8px;">
    <label>Planets</label>
    <div id="edit-star-planet-list" style="max-height:120px; overflow-y:auto; margin-top:4px;"></div>
    <div class="btn-row">
      <button class="btn" id="btn-edit-save">Save</button>
      <button class="btn" id="btn-edit-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Edit Planet Modal -->
<div id="edit-planet-overlay">
  <div id="edit-modal">
    <h3>Edit Planet</h3>
    <input type="hidden" id="edit-planet-id">
    <label for="edit-planet-name">Name</label>
    <input type="text" id="edit-planet-name">
    <div class="edit-coord-row">
      <div>
        <label for="edit-planet-radius">Radius (AU)</label>
        <input type="number" id="edit-planet-radius" min="0.01" step="any">
      </div>
      <div>
        <label for="edit-planet-angle">Angle (°)</label>
        <input type="number" id="edit-planet-angle" min="0" max="360" step="any">
      </div>
    </div>
    <label for="edit-planet-class">Classification</label>
    <select id="edit-planet-class">
      <option value="terrestrial">Terrestrial</option>
      <option value="gas_giant">Gas Giant</option>
      <option value="ice_giant">Ice Giant</option>
    </select>
    <label for="edit-planet-size">Size / Radius (AU)</label>
    <div class="size-slider-group">
      <input type="range" id="edit-planet-size" min="-5" max="-1" step="0.01">
      <span class="size-value" id="edit-planet-size-value">0.0000426 AU</span>
    </div>
    <hr style="border:none; border-top:1px solid rgba(100,140,255,0.15); margin:12px 0 8px;">
    <label>Moons</label>
    <div id="edit-planet-moon-list" style="max-height:120px; overflow-y:auto; margin-top:4px;"></div>
    <button class="btn" id="btn-edit-planet-add-moon" style="width:100%; margin-top:6px; font-size:11px;">Add Moon</button>
    <div class="btn-row">
      <button class="btn" id="btn-edit-planet-save">Save</button>
      <button class="btn" id="btn-edit-planet-cancel">Cancel</button>
    </div>
    <button class="btn" id="btn-edit-planet-delete" style="width:100%; margin-top:8px; background:rgba(255,60,60,0.15); border-color:rgba(255,80,80,0.4); color:#ff6666;">Delete Planet</button>
  </div>
</div>

<!-- Bulk Add Stars Modal -->
<div id="bulk-add-overlay">
  <div id="edit-modal">
    <h3>Bulk Add Stars</h3>
    <label for="bulk-group-name">Group Name</label>
    <input type="text" id="bulk-group-name" placeholder="optional (auto-numbered)">
    <label for="bulk-count">Number of Stars</label>
    <input type="number" id="bulk-count" placeholder="10" min="1" max="10000" step="1">
    <label for="bulk-min-dist">Minimum Distance (ly)</label>
    <input type="number" id="bulk-min-dist" placeholder="3" min="0" step="any">
    <label for="bulk-shape">Area Shape</label>
    <select id="bulk-shape">
      <option value="box">Box</option>
      <option value="sphere">Sphere</option>
    </select>
    <div id="bulk-box-fields">
      <label style="margin-top:8px; font-size:11px; color:#88aacc;">Center (ly)</label>
      <div class="edit-coord-row">
        <div><label for="bulk-cx">X</label><input type="number" id="bulk-cx" placeholder="500" step="any"></div>
        <div><label for="bulk-cy">Y</label><input type="number" id="bulk-cy" placeholder="500" step="any"></div>
        <div><label for="bulk-cz">Z</label><input type="number" id="bulk-cz" placeholder="500" step="any"></div>
      </div>
      <label style="margin-top:8px; font-size:11px; color:#88aacc;">Size (ly)</label>
      <div class="edit-coord-row">
        <div><label for="bulk-w">Width</label><input type="number" id="bulk-w" placeholder="100" min="0" step="any"></div>
        <div><label for="bulk-h">Height</label><input type="number" id="bulk-h" placeholder="100" min="0" step="any"></div>
        <div><label for="bulk-d">Depth</label><input type="number" id="bulk-d" placeholder="100" min="0" step="any"></div>
      </div>
    </div>
    <div id="bulk-sphere-fields" style="display:none;">
      <label style="margin-top:8px; font-size:11px; color:#88aacc;">Center (ly)</label>
      <div class="edit-coord-row">
        <div><label for="bulk-scx">X</label><input type="number" id="bulk-scx" placeholder="500" step="any"></div>
        <div><label for="bulk-scy">Y</label><input type="number" id="bulk-scy" placeholder="500" step="any"></div>
        <div><label for="bulk-scz">Z</label><input type="number" id="bulk-scz" placeholder="500" step="any"></div>
      </div>
      <label for="bulk-sr" style="margin-top:8px;">Radius (ly)</label>
      <input type="number" id="bulk-sr" placeholder="50" min="0" step="any">
    </div>
    <label for="bulk-zone">Zone (optional)</label>
    <select id="bulk-zone"><option value="">None</option></select>
    <label style="display:flex; align-items:center; gap:6px; margin-top:8px; cursor:pointer;">
      <input type="checkbox" id="bulk-create-folder" checked> Create folder for group
    </label>
    <div id="bulk-status" style="display:none; margin-top:8px; font-size:12px; color:#88aacc;"></div>
    <div class="btn-row">
      <button class="btn" id="btn-bulk-generate">Generate</button>
      <button class="btn" id="btn-bulk-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Solar System Popup -->
<div id="solar-system-overlay">
  <div id="solar-system-popup">
    <span id="solar-system-close" title="Close">&times;</span>
    <h3 id="solar-system-title">Solar System</h3>
    <canvas id="solar-system-canvas" width="560" height="480"></canvas>
    <div class="btn-row-bottom">
      <button class="btn" id="btn-solar-recenter">Recenter</button>
      <button class="btn" id="btn-solar-add-planet">Add Planet</button>
      <button class="btn" id="btn-solar-edit-star">Edit Solar System</button>
    </div>
  </div>
</div>

<!-- Add Planet Modal -->
<div id="add-planet-overlay">
  <div id="edit-modal">
    <span class="edit-close" id="add-planet-close" title="Close">&times;</span>
    <h3>Add Planet</h3>
    <input type="hidden" id="add-planet-star-id">
    <label for="add-planet-name">Name</label>
    <input type="text" id="add-planet-name" placeholder="Planet name">
    <div class="edit-coord-row" style="margin-top:6px;">
      <div>
        <label for="add-planet-radius">Radius (AU)</label>
        <input type="number" id="add-planet-radius" placeholder="1" min="0.01" step="any">
      </div>
      <div>
        <label for="add-planet-angle">Angle (°)</label>
        <input type="number" id="add-planet-angle" placeholder="0" min="0" max="360" step="any">
      </div>
    </div>
    <label for="add-planet-class">Classification</label>
    <select id="add-planet-class">
      <option value="terrestrial">Terrestrial</option>
      <option value="gas_giant">Gas Giant</option>
      <option value="ice_giant">Ice Giant</option>
    </select>
    <label for="add-planet-size">Size / Radius (AU)</label>
    <div class="size-slider-group">
      <input type="range" id="add-planet-size" min="-5" max="-1" step="0.01">
      <span class="size-value" id="add-planet-size-value">0.0000426 AU</span>
    </div>
    <button class="btn" id="btn-add-planet" style="width:100%; margin-top:10px;">Add Planet</button>
  </div>
</div>

<!-- Add Moon Modal -->
<div id="add-moon-overlay">
  <div id="edit-modal">
    <span class="edit-close" id="add-moon-close" title="Close">&times;</span>
    <h3>Add Moon</h3>
    <input type="hidden" id="add-moon-planet-id">
    <label for="add-moon-name">Name</label>
    <input type="text" id="add-moon-name" placeholder="Moon name">
    <div class="edit-coord-row" style="margin-top:6px;">
      <div>
        <label for="add-moon-radius">Orbital Radius (AU)</label>
        <input type="number" id="add-moon-radius" placeholder="0.01" min="0.0001" step="any">
      </div>
      <div>
        <label for="add-moon-angle">Angle (&deg;)</label>
        <input type="number" id="add-moon-angle" placeholder="0" min="0" max="360" step="any">
      </div>
    </div>
    <label for="add-moon-size">Size / Radius (AU)</label>
    <div class="size-slider-group">
      <input type="range" id="add-moon-size" min="-6" max="-2" step="0.01">
      <span class="size-value" id="add-moon-size-value">0.00002 AU</span>
    </div>
    <button class="btn" id="btn-add-moon" style="width:100%; margin-top:10px;">Add Moon</button>
  </div>
</div>

<!-- Edit Moon Modal -->
<div id="edit-moon-overlay">
  <div id="edit-modal">
    <h3>Edit Moon</h3>
    <input type="hidden" id="edit-moon-id">
    <label for="edit-moon-name">Name</label>
    <input type="text" id="edit-moon-name">
    <div class="edit-coord-row">
      <div>
        <label for="edit-moon-radius">Orbital Radius (AU)</label>
        <input type="number" id="edit-moon-radius" min="0.0001" step="any">
      </div>
      <div>
        <label for="edit-moon-angle">Angle (&deg;)</label>
        <input type="number" id="edit-moon-angle" min="0" max="360" step="any">
      </div>
    </div>
    <label for="edit-moon-size">Size / Radius (AU)</label>
    <div class="size-slider-group">
      <input type="range" id="edit-moon-size" min="-6" max="-2" step="0.01">
      <span class="size-value" id="edit-moon-size-value">0.00002 AU</span>
    </div>
    <div class="btn-row">
      <button class="btn" id="btn-edit-moon-save">Save</button>
      <button class="btn" id="btn-edit-moon-cancel">Cancel</button>
    </div>
    <button class="btn" id="btn-edit-moon-delete" style="width:100%; margin-top:8px; background:rgba(255,60,60,0.15); border-color:rgba(255,80,80,0.4); color:#ff6666;">Delete Moon</button>
  </div>
</div>

<!-- Edit Zone Modal -->
<div id="edit-zone-overlay">
  <div id="edit-modal">
    <h3>Edit Zone</h3>
    <input type="hidden" id="edit-zone-id">
    <label for="edit-zone-name">Name</label>
    <input type="text" id="edit-zone-name">
    <label for="edit-zone-color">Color</label>
    <select id="edit-zone-color">
      <option value="red">Red</option>
      <option value="blue">Blue</option>
      <option value="yellow">Yellow</option>
      <option value="green">Green</option>
      <option value="gray">Gray</option>
    </select>
    <label>Stars in zone</label>
    <div id="edit-zone-star-list" style="max-height:120px; overflow-y:auto; margin-top:4px;"></div>
    <div class="btn-row">
      <button class="btn" id="btn-edit-zone-save">Save</button>
      <button class="btn" id="btn-edit-zone-cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Instructions -->
<div id="instructions">
  <strong style="color:#7ab4ff;">Controls</strong><br>
  Right-click + drag: Rotate<br>
  Middle-click + drag: Pan<br>
  Scroll: Zoom<br>
  Click star: Select<br>
  Shift + click: Multi-select<br>
  Double-click star: View System<br>
  Right-click star: Options
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';

// ── Constants ─────────────────────────────────────────
const UNIVERSE_SIZE = 1000; // light years per axis
const PX_PER_LY = 75;      // 1 light year = 75 pixels/units in 3D space
const WORLD_SIZE = UNIVERSE_SIZE * PX_PER_LY; // 10000 units total
const ZONE_PADDING = 1;    // light years around each star in a zone

const ZONE_COLORS = {
  red:    { hex: 0xff4444, css: '#ff4444' },
  blue:   { hex: 0x4488ff, css: '#4488ff' },
  yellow: { hex: 0xffcc44, css: '#ffcc44' },
  green:  { hex: 0x44cc66, css: '#44cc66' },
  gray:   { hex: 0x999999, css: '#999999' },
};

// Helper: convert light-year coords to world (pixel) coords
function lyToWorld(v) { return v * PX_PER_LY; }

// Unit system
const LY_PER_AU = 0.00001581251; // 1 AU in light years
const AU_PER_LY = 1 / LY_PER_AU; // ~63,241.077 AU per light year
let displayUnit = 'ly'; // 'ly' or 'au'

function formatCoord(lyValue) {
  if (displayUnit === 'au') return (lyValue * AU_PER_LY).toFixed(1);
  return lyValue.toFixed(1);
}

function formatDist(lyValue) {
  if (displayUnit === 'au') return (lyValue * AU_PER_LY).toFixed(2);
  return lyValue.toFixed(2);
}

function unitLabel() {
  return displayUnit === 'au' ? 'AU' : 'ly';
}

// Minimum star world-space size (0.00465 AU ≈ solar radius)
const STAR_MIN_AU = 0.00465;
const STAR_MIN_WORLD = STAR_MIN_AU * LY_PER_AU * PX_PER_LY;

// Screen-space sizing for stars and labels (in pixels on screen)
const STAR_SCREEN_SIZE = 16;   // star sprite diameter in screen pixels
const LABEL_SCREEN_WIDTH = 120; // name label width in screen pixels
const LABEL_SCREEN_HEIGHT = 30; // name label height in screen pixels
const STAR_LABEL_VISIBLE_DIST = lyToWorld(50);  // star names visible within 50 ly
const STAR_LABEL_FADE_DIST = lyToWorld(10);     // fade in over 10 ly
const ZONE_LABEL_SCREEN_WIDTH = 160;  // zone label width in screen pixels
const ZONE_LABEL_SCREEN_HEIGHT = 40;  // zone label height in screen pixels

// Planet rendering
const PLANET_SCREEN_SIZE = 10;       // planet sprite diameter in screen pixels
const PLANET_LABEL_SCREEN_WIDTH = 90;
const PLANET_LABEL_SCREEN_HEIGHT = 22;
const AU_TO_WORLD = 20;              // 1 AU = 20 world units (exaggerated for visibility)
const PLANET_VISIBLE_DIST = lyToWorld(5); // planets visible within 5 ly of parent star

const PLANET_CLASSIFICATIONS = {
  terrestrial: { hex: 0x88aa55, css: '#88aa55', label: 'Terrestrial', defaultSize: 0.0000426 },  // ~Earth radius in AU
  gas_giant:   { hex: 0xdd9944, css: '#dd9944', label: 'Gas Giant',   defaultSize: 0.000467 },   // ~Jupiter radius in AU
  ice_giant:   { hex: 0x66bbdd, css: '#66bbdd', label: 'Ice Giant',   defaultSize: 0.000169 },   // ~Neptune radius in AU
};
const DEFAULT_STAR_SIZE = 0.00465; // Solar radius in AU

// ── Log-scale size slider helpers ────────────────────
function sizeToSlider(au) { return Math.log10(au); }
function sliderToSize(val) { return Math.pow(10, parseFloat(val)); }
function formatSize(au) {
  if (au >= 0.01) return au.toFixed(4) + ' AU';
  if (au >= 0.001) return au.toFixed(5) + ' AU';
  if (au >= 0.0001) return au.toFixed(6) + ' AU';
  return au.toExponential(2) + ' AU';
}

function initSizeSlider(sliderId, valueId) {
  const slider = document.getElementById(sliderId);
  const display = document.getElementById(valueId);
  slider.addEventListener('input', () => {
    display.textContent = formatSize(sliderToSize(slider.value));
  });
}

// ── State ─────────────────────────────────────────────
let stars = [];       // { id, name, x, y, z, zoneIds[], folderId } — coords in light years
let zones = [];       // { id, name, color, starIds[] }
let planets = [];     // { id, name, starId, orbitalRadius (AU), orbitalAngle (deg), classification }
let moons = [];       // { id, name, planetId, orbitalRadius (AU), orbitalAngle (deg), size (AU) }
let starFolders = []; // { id, name, collapsed }
let nextFolderId = 1;
let nextStarId = 1;
let nextZoneId = 1;
let nextPlanetId = 1;
let nextMoonId = 1;
let selectedStarIds = new Set();
let lastClickedStarId = null;
let measureMode = false;
let measureSelection = [];
let measureLine = null;
let measureLabel = null;
let isDragSelecting = false;
let dragStartX = 0, dragStartY = 0;
let dragMoved = false;

// ── Three.js Setup ────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020408);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 500000);
camera.position.set(lyToWorld(1400), lyToWorld(1000), lyToWorld(1400));

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(WORLD_SIZE / 2, WORLD_SIZE / 2, WORLD_SIZE / 2);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 0.1;
controls.maxDistance = lyToWorld(3500);
// Swap: right-click = rotate, middle-click = pan
controls.mouseButtons = {
  LEFT: null,
  MIDDLE: THREE.MOUSE.PAN,
  RIGHT: THREE.MOUSE.ROTATE
};
controls.update();

// Default contextmenu prevention is handled in the star context menu handler below

// ── Ambient light ─────────────────────────────────────
scene.add(new THREE.AmbientLight(0xffffff, 0.5));

// ── Grid / Bounding Box ──────────────────────────────
function buildBoundingBox() {
  const S = WORLD_SIZE;
  const geo = new THREE.BufferGeometry();
  const vertices = new Float32Array([
    0,0,0, S,0,0,  S,0,0, S,S,0,  S,S,0, 0,S,0,  0,S,0, 0,0,0,
    0,0,S, S,0,S,  S,0,S, S,S,S,  S,S,S, 0,S,S,  0,S,S, 0,0,S,
    0,0,0, 0,0,S,  S,0,0, S,0,S,  S,S,0, S,S,S,  0,S,0, 0,S,S,
  ]);
  geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  const mat = new THREE.LineBasicMaterial({ color: 0x1a2a4a, transparent: true, opacity: 0.6 });
  scene.add(new THREE.LineSegments(geo, mat));
}
buildBoundingBox();

// ── Floor Grid ────────────────────────────────────────
function buildFloorGrid() {
  const S = WORLD_SIZE;
  const divisions = 10;
  const step = S / divisions;
  const geo = new THREE.BufferGeometry();
  const verts = [];
  for (let i = 0; i <= divisions; i++) {
    const p = i * step;
    verts.push(p, 0, 0, p, 0, S);
    verts.push(0, 0, p, S, 0, p);
  }
  geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts), 3));
  const mat = new THREE.LineBasicMaterial({ color: 0x0e1a30, transparent: true, opacity: 0.5 });
  scene.add(new THREE.LineSegments(geo, mat));
}
buildFloorGrid();

// ── Axis Labels ──────────────────────────────────────
function makeTextSprite(text, position, color = '#7ab4ff') {
  const canvas = document.createElement('canvas');
  const size = 256;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.font = 'Bold 48px Arial';
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, size / 2, size / 2);
  const texture = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.position.copy(position);
  sprite.scale.set(lyToWorld(80), lyToWorld(80), 1);
  sprite.userData.isLabel = true;
  scene.add(sprite);
  return sprite;
}

// Tick labels every 200 ly
for (let i = 0; i <= UNIVERSE_SIZE; i += 200) {
  if (i > 0) {
    const w = lyToWorld(i);
    const off = lyToWorld(-30);
    makeTextSprite(`${i}`, new THREE.Vector3(w, off, 0), '#446688');
    makeTextSprite(`${i}`, new THREE.Vector3(0, w, off), '#446688');
    makeTextSprite(`${i}`, new THREE.Vector3(off, 0, w), '#446688');
  }
}
const axisLabelOff = lyToWorld(-60);
makeTextSprite('X (ly)', new THREE.Vector3(WORLD_SIZE / 2, axisLabelOff, 0), '#ff6666');
makeTextSprite('Y (ly)', new THREE.Vector3(axisLabelOff, WORLD_SIZE / 2, 0), '#66ff66');
makeTextSprite('Z (ly)', new THREE.Vector3(0, axisLabelOff, WORLD_SIZE / 2), '#6688ff');

function buildAxisLines() {
  const len = WORLD_SIZE + lyToWorld(40);
  const axisData = [
    { dir: [len, 0, 0], color: 0xff4444 },
    { dir: [0, len, 0], color: 0x44ff44 },
    { dir: [0, 0, len], color: 0x4488ff },
  ];
  for (const a of axisData) {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0,0,0, ...a.dir]), 3));
    const mat = new THREE.LineBasicMaterial({ color: a.color, transparent: true, opacity: 0.5 });
    scene.add(new THREE.LineSegments(geo, mat));
  }
}
buildAxisLines();

// ── Star Rendering ───────────────────────────────────
const starGroup = new THREE.Group();
scene.add(starGroup);
const nameSprites = new THREE.Group();
scene.add(nameSprites);
const zoneGroup = new THREE.Group();
scene.add(zoneGroup);
const planetGroup = new THREE.Group();  // kept for data, not added to scene
const planetLabelGroup = new THREE.Group();

// Selection ring for highlighted star
function createSelectionRingTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  // Outer glow
  ctx.beginPath();
  ctx.arc(128, 128, 100, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255, 180, 40, 0.25)';
  ctx.lineWidth = 30;
  ctx.stroke();
  // Main ring
  ctx.beginPath();
  ctx.arc(128, 128, 100, 0, Math.PI * 2);
  ctx.strokeStyle = '#ffaa22';
  ctx.lineWidth = 8;
  ctx.stroke();
  // Corner brackets for extra visibility
  const s = 40;
  ctx.strokeStyle = '#ffcc44';
  ctx.lineWidth = 5;
  // Top-left
  ctx.beginPath(); ctx.moveTo(28, 58); ctx.lineTo(28, 28); ctx.lineTo(58, 28); ctx.stroke();
  // Top-right
  ctx.beginPath(); ctx.moveTo(198, 28); ctx.lineTo(228, 28); ctx.lineTo(228, 58); ctx.stroke();
  // Bottom-left
  ctx.beginPath(); ctx.moveTo(28, 198); ctx.lineTo(28, 228); ctx.lineTo(58, 228); ctx.stroke();
  // Bottom-right
  ctx.beginPath(); ctx.moveTo(198, 228); ctx.lineTo(228, 228); ctx.lineTo(228, 198); ctx.stroke();
  return new THREE.CanvasTexture(canvas);
}
const selectionRingTexture = createSelectionRingTexture();
const selectionRingGroup = new THREE.Group();
selectionRingGroup.renderOrder = 999;
scene.add(selectionRingGroup);

function ensureSelectionRings(count) {
  while (selectionRingGroup.children.length < count) {
    const mat = new THREE.SpriteMaterial({ map: selectionRingTexture, transparent: true, depthTest: false });
    const ring = new THREE.Sprite(mat);
    ring.renderOrder = 999;
    ring.visible = false;
    selectionRingGroup.add(ring);
  }
}

function createPlanetTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 28);
  gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
  gradient.addColorStop(0.3, 'rgba(200,200,200,0.7)');
  gradient.addColorStop(0.7, 'rgba(150,150,150,0.3)');
  gradient.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);
  return new THREE.CanvasTexture(canvas);
}
const planetTexture = createPlanetTexture();

function createStarTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255,255,255,1)');
  gradient.addColorStop(0.15, 'rgba(200,220,255,0.9)');
  gradient.addColorStop(0.4, 'rgba(100,150,255,0.4)');
  gradient.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);
  return new THREE.CanvasTexture(canvas);
}
const starTexture = createStarTexture();

function rebuildStarMeshes() {
  while (starGroup.children.length) starGroup.remove(starGroup.children[0]);
  while (nameSprites.children.length) nameSprites.remove(nameSprites.children[0]);

  for (const star of stars) {
    const wx = lyToWorld(star.x), wy = lyToWorld(star.y), wz = lyToWorld(star.z);

    const mat = new THREE.SpriteMaterial({
      map: starTexture,
      color: 0xffffff,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthTest: false,
    });
    const sprite = new THREE.Sprite(mat);
    sprite.position.set(wx, wy, wz);
    sprite.scale.set(1, 1, 1); // dynamically sized in animate()
    sprite.userData.starId = star.id;
    starGroup.add(sprite);

    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = '36px Arial';
    ctx.fillStyle = '#aaccff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(star.name, 256, 64);
    const tex = new THREE.CanvasTexture(canvas);
    const labelMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    const label = new THREE.Sprite(labelMat);
    label.position.set(wx, wy, wz); // offset applied dynamically in animate()
    label.scale.set(1, 1, 1); // dynamically sized in animate()
    label.userData.starId = star.id;
    nameSprites.add(label);
  }
}

// ── Zone Rendering ───────────────────────────────────
function rebuildZoneMeshes() {
  while (zoneGroup.children.length) zoneGroup.remove(zoneGroup.children[0]);

  for (const zone of zones) {
    if (zone.hidden) continue;
    const zoneStars = stars.filter(st => zone.starIds.includes(st.id));
    if (zoneStars.length === 0) continue;

    const colorInfo = ZONE_COLORS[zone.color] || ZONE_COLORS.gray;
    const padWorld = lyToWorld(ZONE_PADDING);

    if (zoneStars.length === 1) {
      const geo = new THREE.SphereGeometry(padWorld, 16, 12);
      const mat = new THREE.MeshBasicMaterial({
        color: colorInfo.hex, transparent: true, opacity: 0.18,
        depthWrite: false, side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(lyToWorld(zoneStars[0].x), lyToWorld(zoneStars[0].y), lyToWorld(zoneStars[0].z));
      zoneGroup.add(mesh);

      const wireMat = new THREE.MeshBasicMaterial({
        color: colorInfo.hex, transparent: true, opacity: 0.3, wireframe: true
      });
      const wireMesh = new THREE.Mesh(geo.clone(), wireMat);
      wireMesh.position.copy(mesh.position);
      zoneGroup.add(wireMesh);
    } else {
      const points = [];
      const icoGeo = new THREE.IcosahedronGeometry(padWorld, 1);
      const icoPos = icoGeo.getAttribute('position');

      for (const st of zoneStars) {
        const wx = lyToWorld(st.x), wy = lyToWorld(st.y), wz = lyToWorld(st.z);
        for (let i = 0; i < icoPos.count; i++) {
          points.push(new THREE.Vector3(
            wx + icoPos.getX(i),
            wy + icoPos.getY(i),
            wz + icoPos.getZ(i)
          ));
        }
      }

      try {
        const hullGeo = new ConvexGeometry(points);
        const mat = new THREE.MeshBasicMaterial({
          color: colorInfo.hex, transparent: true, opacity: 0.15,
          depthWrite: false, side: THREE.DoubleSide
        });
        zoneGroup.add(new THREE.Mesh(hullGeo, mat));

        const edgeGeo = new THREE.EdgesGeometry(hullGeo);
        const edgeMat = new THREE.LineBasicMaterial({
          color: colorInfo.hex, transparent: true, opacity: 0.3
        });
        zoneGroup.add(new THREE.LineSegments(edgeGeo, edgeMat));
      } catch (e) {
        for (const st of zoneStars) {
          const geo = new THREE.SphereGeometry(padWorld, 12, 8);
          const mat = new THREE.MeshBasicMaterial({
            color: colorInfo.hex, transparent: true, opacity: 0.18,
            depthWrite: false, side: THREE.DoubleSide
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(lyToWorld(st.x), lyToWorld(st.y), lyToWorld(st.z));
          zoneGroup.add(mesh);
        }
      }
    }

    // Zone name label at centroid
    const cx = zoneStars.reduce((a, s) => a + s.x, 0) / zoneStars.length;
    const cy = zoneStars.reduce((a, s) => a + s.y, 0) / zoneStars.length;
    const cz = zoneStars.reduce((a, s) => a + s.z, 0) / zoneStars.length;

    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = 'Bold 32px Arial';
    ctx.fillStyle = colorInfo.css;
    ctx.globalAlpha = 0.7;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(zone.name, 256, 64);
    const tex = new THREE.CanvasTexture(canvas);
    const labelMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    const label = new THREE.Sprite(labelMat);
    label.position.set(lyToWorld(cx), lyToWorld(cy), lyToWorld(cz));
    label.scale.set(1, 1, 1); // dynamically sized in animate()
    label.userData.isZoneLabel = true;
    label.userData.anchorY = lyToWorld(cy);
    zoneGroup.add(label);
  }
}

// ── Auto-Assign Stars to Zones ───────────────────────
function isPointInConvexHull(point, geometry) {
  const pos = geometry.getAttribute('position');
  const idx = geometry.getIndex();
  const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
  const ab = new THREE.Vector3(), ac = new THREE.Vector3(), normal = new THREE.Vector3(), ap = new THREE.Vector3();

  // Compute centroid to determine correct normal orientation
  const centroid = new THREE.Vector3();
  for (let i = 0; i < pos.count; i++) {
    centroid.x += pos.getX(i);
    centroid.y += pos.getY(i);
    centroid.z += pos.getZ(i);
  }
  centroid.divideScalar(pos.count);

  const faceCount = idx ? idx.count / 3 : pos.count / 3;
  for (let f = 0; f < faceCount; f++) {
    const i0 = idx ? idx.getX(f * 3) : f * 3;
    const i1 = idx ? idx.getX(f * 3 + 1) : f * 3 + 1;
    const i2 = idx ? idx.getX(f * 3 + 2) : f * 3 + 2;
    a.fromBufferAttribute(pos, i0);
    b.fromBufferAttribute(pos, i1);
    c.fromBufferAttribute(pos, i2);
    ab.subVectors(b, a);
    ac.subVectors(c, a);
    normal.crossVectors(ab, ac);
    // Ensure normal points outward (away from centroid)
    ap.subVectors(centroid, a);
    if (normal.dot(ap) > 0) normal.negate();
    // Check if point is outside this face
    ap.subVectors(point, a);
    if (normal.dot(ap) > 0.001) return false;
  }
  return true;
}

function autoAssignStarsToZones() {
  let changed = false;
  const padWorld = lyToWorld(ZONE_PADDING);

  for (const zone of zones) {
    const zoneStars = stars.filter(s => zone.starIds.includes(s.id));
    if (zoneStars.length === 0) continue;

    if (zoneStars.length === 1) {
      // Sphere test: any star within ZONE_PADDING of the single star
      const seed = zoneStars[0];
      const sx = lyToWorld(seed.x), sy = lyToWorld(seed.y), sz = lyToWorld(seed.z);
      for (const star of stars) {
        if (zone.starIds.includes(star.id)) continue;
        const dx = lyToWorld(star.x) - sx, dy = lyToWorld(star.y) - sy, dz = lyToWorld(star.z) - sz;
        if (Math.sqrt(dx * dx + dy * dy + dz * dz) <= padWorld) {
          if (!star.zoneIds) star.zoneIds = [];
          if (!star.zoneIds.includes(zone.id)) star.zoneIds.push(zone.id);
          if (!zone.starIds.includes(star.id)) zone.starIds.push(star.id);
          changed = true;
        }
      }
    } else {
      // Convex hull test
      const points = [];
      const icoGeo = new THREE.IcosahedronGeometry(padWorld, 1);
      const icoPos = icoGeo.getAttribute('position');
      for (const st of zoneStars) {
        const wx = lyToWorld(st.x), wy = lyToWorld(st.y), wz = lyToWorld(st.z);
        for (let i = 0; i < icoPos.count; i++) {
          points.push(new THREE.Vector3(wx + icoPos.getX(i), wy + icoPos.getY(i), wz + icoPos.getZ(i)));
        }
      }
      try {
        const hullGeo = new ConvexGeometry(points);
        for (const star of stars) {
          if (zone.starIds.includes(star.id)) continue;
          const wp = new THREE.Vector3(lyToWorld(star.x), lyToWorld(star.y), lyToWorld(star.z));
          if (isPointInConvexHull(wp, hullGeo)) {
            if (!star.zoneIds) star.zoneIds = [];
            if (!star.zoneIds.includes(zone.id)) star.zoneIds.push(zone.id);
            if (!zone.starIds.includes(star.id)) zone.starIds.push(star.id);
            changed = true;
          }
        }
      } catch (e) { /* hull failed, skip */ }
    }
  }

  if (changed) {
    rebuildZoneMeshes(); // hull may have grown with new members
    updateStarList();
    updateZoneList();
    saveToLocalStorage();
  }
}

// ── Planet Rendering ─────────────────────────────────
function rebuildPlanetMeshes() {
  while (planetGroup.children.length) planetGroup.remove(planetGroup.children[0]);
  while (planetLabelGroup.children.length) planetLabelGroup.remove(planetLabelGroup.children[0]);

  for (const planet of planets) {
    const star = stars.find(s => s.id === planet.starId);
    if (!star) continue;

    const classInfo = PLANET_CLASSIFICATIONS[planet.classification] || PLANET_CLASSIFICATIONS.terrestrial;
    const angleRad = (planet.orbitalAngle * Math.PI) / 180;
    const orbitWorld = planet.orbitalRadius * AU_TO_WORLD;

    const wx = lyToWorld(star.x) + Math.cos(angleRad) * orbitWorld;
    const wy = lyToWorld(star.y);
    const wz = lyToWorld(star.z) + Math.sin(angleRad) * orbitWorld;

    const mat = new THREE.SpriteMaterial({
      map: planetTexture,
      color: classInfo.hex,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthTest: false,
    });
    const sprite = new THREE.Sprite(mat);
    sprite.position.set(wx, wy, wz);
    sprite.scale.set(1, 1, 1);
    sprite.userData.planetId = planet.id;
    sprite.userData.starId = planet.starId;
    sprite.visible = false; // controlled in animate()
    planetGroup.add(sprite);

    // Planet name label
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = '30px Arial';
    ctx.fillStyle = classInfo.css;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(planet.name, 256, 64);
    const tex = new THREE.CanvasTexture(canvas);
    const labelMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    const label = new THREE.Sprite(labelMat);
    label.position.set(wx, wy, wz);
    label.scale.set(1, 1, 1);
    label.userData.planetId = planet.id;
    label.userData.starId = planet.starId;
    label.visible = false;
    planetLabelGroup.add(label);
  }

  // Refresh solar system popup if open
  if (solarSystemStarId !== null) redrawSolarSystem();
}

// ── Star CRUD ────────────────────────────────────────
function addStar(name, x, y, z, zoneId = null, size = DEFAULT_STAR_SIZE) {
  const zoneIds = zoneId ? [zoneId] : [];
  const star = { id: nextStarId++, name, x: parseFloat(x), y: parseFloat(y), z: parseFloat(z), zoneIds, size: parseFloat(size), folderId: null };
  stars.push(star);
  for (const zid of star.zoneIds) {
    const zone = zones.find(z => z.id === zid);
    if (zone && !zone.starIds.includes(star.id)) zone.starIds.push(star.id);
  }
  rebuildStarMeshes();
  rebuildZoneMeshes();
  autoAssignStarsToZones();
  updateStarList();
  updateZoneList();
  saveToLocalStorage();
  return star;
}

function updateStar(id, name, x, y, z, newZoneIds, size, folderId) {
  const star = stars.find(s => s.id === id);
  if (!star) return;
  const oldZoneIds = star.zoneIds || [];
  star.name = name;
  star.x = parseFloat(x);
  star.y = parseFloat(y);
  star.z = parseFloat(z);
  star.size = parseFloat(size) || DEFAULT_STAR_SIZE;
  if (folderId !== undefined) star.folderId = folderId;

  // Sync zone memberships
  if (newZoneIds !== undefined) {
    star.zoneIds = newZoneIds;
    // Remove star from zones it's no longer in
    for (const oldZid of oldZoneIds) {
      if (!newZoneIds.includes(oldZid)) {
        const zone = zones.find(z => z.id === oldZid);
        if (zone) zone.starIds = zone.starIds.filter(sid => sid !== id);
      }
    }
    // Add star to zones it's newly in
    for (const newZid of newZoneIds) {
      const zone = zones.find(z => z.id === newZid);
      if (zone && !zone.starIds.includes(id)) zone.starIds.push(id);
    }
  }

  rebuildStarMeshes();
  rebuildZoneMeshes();
  autoAssignStarsToZones();
  updateStarList();
  updateZoneList();
  saveToLocalStorage();
}

function removeStar(id) {
  const star = stars.find(s => s.id === id);
  if (star && star.zoneIds) {
    for (const zid of star.zoneIds) {
      const zone = zones.find(z => z.id === zid);
      if (zone) zone.starIds = zone.starIds.filter(sid => sid !== id);
    }
  }
  stars = stars.filter(s => s.id !== id);
  const removedPlanetIds = planets.filter(p => p.starId === id).map(p => p.id);
  planets = planets.filter(p => p.starId !== id);
  moons = moons.filter(m => !removedPlanetIds.includes(m.planetId));
  measureSelection = measureSelection.filter(s => !(s.type === 'star' && s.id === id));
  selectedStarIds.delete(id);
  clearMeasureLine();
  rebuildStarMeshes();
  rebuildPlanetMeshes();
  rebuildZoneMeshes();
  updateStarList();
  updateZoneList();
  saveToLocalStorage();
}

// ── Zone CRUD ────────────────────────────────────────
function addZone(name, color) {
  const zone = { id: nextZoneId++, name, color, starIds: [], hidden: false };
  zones.push(zone);
  updateZoneList();
  updateZoneDropdowns();
  saveToLocalStorage();
  return zone;
}

function removeZone(id) {
  for (const star of stars) {
    if (star.zoneIds) star.zoneIds = star.zoneIds.filter(zid => zid !== id);
  }
  zones = zones.filter(z => z.id !== id);
  rebuildZoneMeshes();
  updateZoneList();
  updateZoneDropdowns();
  updateStarList();
  saveToLocalStorage();
}

// ── Planet CRUD ──────────────────────────────────────
function addPlanet(name, starId, orbitalRadius, orbitalAngle, classification, size) {
  const defaultSize = (PLANET_CLASSIFICATIONS[classification] || PLANET_CLASSIFICATIONS.terrestrial).defaultSize;
  const planet = { id: nextPlanetId++, name, starId, orbitalRadius: parseFloat(orbitalRadius), orbitalAngle: parseFloat(orbitalAngle), classification, size: parseFloat(size) || defaultSize };
  planets.push(planet);
  rebuildPlanetMeshes();
  saveToLocalStorage();
  return planet;
}

function updatePlanet(id, name, orbitalRadius, orbitalAngle, classification, size) {
  const planet = planets.find(p => p.id === id);
  if (!planet) return;
  planet.name = name;
  planet.orbitalRadius = parseFloat(orbitalRadius);
  planet.orbitalAngle = parseFloat(orbitalAngle);
  planet.classification = classification;
  const defaultSize = (PLANET_CLASSIFICATIONS[classification] || PLANET_CLASSIFICATIONS.terrestrial).defaultSize;
  planet.size = parseFloat(size) || defaultSize;
  rebuildPlanetMeshes();
  saveToLocalStorage();
}

function removePlanet(id) {
  planets = planets.filter(p => p.id !== id);
  moons = moons.filter(m => m.planetId !== id);
  measureSelection = measureSelection.filter(s => !(s.type === 'planet' && s.id === id));
  clearMeasureLine();
  rebuildPlanetMeshes();
  saveToLocalStorage();
}

// ── Moon CRUD ────────────────────────────────────────
const DEFAULT_MOON_SIZE = 0.00002; // ~Luna radius in AU

function addMoon(name, planetId, orbitalRadius, orbitalAngle, size) {
  const moon = { id: nextMoonId++, name, planetId, orbitalRadius: parseFloat(orbitalRadius), orbitalAngle: parseFloat(orbitalAngle), size: parseFloat(size) || DEFAULT_MOON_SIZE };
  moons.push(moon);
  rebuildPlanetMeshes();
  saveToLocalStorage();
  return moon;
}

function updateMoon(id, name, orbitalRadius, orbitalAngle, size) {
  const moon = moons.find(m => m.id === id);
  if (!moon) return;
  moon.name = name;
  moon.orbitalRadius = parseFloat(orbitalRadius);
  moon.orbitalAngle = parseFloat(orbitalAngle);
  moon.size = parseFloat(size) || DEFAULT_MOON_SIZE;
  rebuildPlanetMeshes();
  saveToLocalStorage();
}

function removeMoon(id) {
  moons = moons.filter(m => m.id !== id);
  measureSelection = measureSelection.filter(s => !(s.type === 'moon' && s.id === id));
  clearMeasureLine();
  rebuildPlanetMeshes();
  saveToLocalStorage();
}

// ── Distance Measurement ─────────────────────────────
function clearMeasureLine() {
  if (measureLine) { scene.remove(measureLine); measureLine = null; }
  if (measureLabel) { scene.remove(measureLabel); measureLabel = null; }
  document.getElementById('distance-result').classList.remove('visible');
}

// Get world position and name for a measure target { type: 'star'|'planet', id }
function getMeasureTarget(sel) {
  if (sel.type === 'star') {
    const s = stars.find(st => st.id === sel.id);
    if (!s) return null;
    return { name: s.name, wx: lyToWorld(s.x), wy: lyToWorld(s.y), wz: lyToWorld(s.z), lyX: s.x, lyY: s.y, lyZ: s.z };
  } else {
    const p = planets.find(pl => pl.id === sel.id);
    if (!p) return null;
    const star = stars.find(s => s.id === p.starId);
    if (!star) return null;
    const angleRad = (p.orbitalAngle * Math.PI) / 180;
    const orbitWorld = p.orbitalRadius * AU_TO_WORLD;
    const wx = lyToWorld(star.x) + Math.cos(angleRad) * orbitWorld;
    const wy = lyToWorld(star.y);
    const wz = lyToWorld(star.z) + Math.sin(angleRad) * orbitWorld;
    // Use real AU-to-LY conversion for distance, not the exaggerated visual scale
    const orbitLy = p.orbitalRadius * LY_PER_AU;
    const lyX = star.x + Math.cos(angleRad) * orbitLy;
    const lyY = star.y;
    const lyZ = star.z + Math.sin(angleRad) * orbitLy;
    return { name: p.name, wx, wy, wz, lyX, lyY, lyZ };
  }
}

function drawMeasureLine(sel1, sel2) {
  clearMeasureLine();
  const t1 = getMeasureTarget(sel1);
  const t2 = getMeasureTarget(sel2);
  if (!t1 || !t2) return;

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
    t1.wx, t1.wy, t1.wz,
    t2.wx, t2.wy, t2.wz
  ]), 3));
  const mat = new THREE.LineBasicMaterial({ color: 0xffcc44, linewidth: 2, transparent: true, opacity: 0.8 });
  measureLine = new THREE.LineSegments(geo, mat);
  scene.add(measureLine);

  // Distance in light years
  const dx = t2.lyX - t1.lyX, dy = t2.lyY - t1.lyY, dz = t2.lyZ - t1.lyZ;
  const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

  const mx = (t1.wx + t2.wx) / 2;
  const my = (t1.wy + t2.wy) / 2 + lyToWorld(20);
  const mz = (t1.wz + t2.wz) / 2;
  const distAU = dist * AU_PER_LY;
  const lyText = `${dist.toFixed(4)} ly`;
  const auText = `${distAU.toFixed(2)} AU`;

  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 160;
  const ctx = canvas.getContext('2d');
  ctx.font = 'Bold 34px Arial';
  ctx.fillStyle = '#ffcc44';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(lyText, 256, 50);
  ctx.fillText(auText, 256, 110);
  const tex = new THREE.CanvasTexture(canvas);
  const labelMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  measureLabel = new THREE.Sprite(labelMat);
  measureLabel.position.set(mx, my, mz);
  measureLabel.scale.set(1, 1, 1); // dynamically sized in animate()
  measureLabel.userData.isMeasureLabel = true;
  scene.add(measureLabel);

  const resultEl = document.getElementById('distance-result');
  const textEl = document.getElementById('distance-text');
  textEl.innerHTML = `<strong>${t1.name}</strong> &rarr; <strong>${t2.name}</strong><br>${lyText} / ${auText}`;
  resultEl.classList.add('visible');
}

// ── Raycasting ───────────────────────────────────────
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredStar = null;

function getIntersectedStar(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  // Dynamic threshold based on current camera distance to scene center
  const camDist = camera.position.distanceTo(controls.target);
  raycaster.params.Sprite = { threshold: screenToWorld(STAR_SCREEN_SIZE * 0.75, camDist) };
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(starGroup.children);
  // Only allow selecting stars within a distance proportional to zoom level
  const maxSelectDist = camDist * 3;
  for (const hit of hits) {
    if (camera.position.distanceTo(hit.object.position) <= maxSelectDist) {
      const id = hit.object.userData.starId;
      return stars.find(s => s.id === id) || null;
    }
  }
  return null;
}

function getIntersectedPlanet(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  const camDist = camera.position.distanceTo(controls.target);
  raycaster.params.Sprite = { threshold: screenToWorld(PLANET_SCREEN_SIZE * 0.75, camDist) };
  raycaster.setFromCamera(mouse, camera);
  const visiblePlanets = planetGroup.children.filter(c => c.visible);
  const hits = raycaster.intersectObjects(visiblePlanets);
  if (hits.length > 0) {
    const id = hits[0].object.userData.planetId;
    return planets.find(p => p.id === id) || null;
  }
  return null;
}

// Tooltip
const tooltip = document.getElementById('star-tooltip');
const tooltipName = document.getElementById('tooltip-name');
const tooltipCoords = document.getElementById('tooltip-coords');
const tooltipZone = document.getElementById('tooltip-zone');

renderer.domElement.addEventListener('mousemove', (e) => {
  // Check planets first (they're smaller, harder to hit)
  const planet = getIntersectedPlanet(e);
  if (planet) {
    const classInfo = PLANET_CLASSIFICATIONS[planet.classification] || PLANET_CLASSIFICATIONS.terrestrial;
    const parentStar = stars.find(s => s.id === planet.starId);
    tooltipName.textContent = planet.name;
    tooltipCoords.textContent = `Orbit: ${planet.orbitalRadius} AU, ${planet.orbitalAngle}°`;
    tooltipZone.textContent = `${classInfo.label} · Star: ${parentStar ? parentStar.name : '?'}`;
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX + 16) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
    document.body.style.cursor = 'pointer';
    hoveredStar = null;
    return;
  }

  const star = getIntersectedStar(e);
  if (star) {
    hoveredStar = star;
    tooltipName.textContent = star.name;
    tooltipCoords.textContent = `(${formatCoord(star.x)}, ${formatCoord(star.y)}, ${formatCoord(star.z)}) ${unitLabel()}`;
    const starZones = (star.zoneIds || []).map(zid => zones.find(z => z.id === zid)).filter(Boolean);
    const planetCount = planets.filter(p => p.starId === star.id).length;
    let info = starZones.length ? `Zone${starZones.length > 1 ? 's' : ''}: ${starZones.map(z => z.name).join(', ')}` : '';
    if (planetCount > 0) info += `${info ? ' · ' : ''}${planetCount} planet${planetCount !== 1 ? 's' : ''}`;
    tooltipZone.textContent = info;
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX + 16) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
    document.body.style.cursor = 'pointer';
  } else {
    hoveredStar = null;
    tooltip.style.display = 'none';
    document.body.style.cursor = 'default';
  }
});

// ── Box Selection (left-click drag) ──────────────────
const selectBox = document.getElementById('select-box');

renderer.domElement.addEventListener('mousedown', (e) => {
  if (e.button === 0 && !measureMode) {
    isDragSelecting = true;
    dragMoved = false;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
  }
});

document.addEventListener('mousemove', (e) => {
  if (!isDragSelecting) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  if (!dragMoved && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
    dragMoved = true;
  }
  if (dragMoved) {
    const x = Math.min(e.clientX, dragStartX);
    const y = Math.min(e.clientY, dragStartY);
    const w = Math.abs(dx);
    const h = Math.abs(dy);
    selectBox.style.left = x + 'px';
    selectBox.style.top = y + 'px';
    selectBox.style.width = w + 'px';
    selectBox.style.height = h + 'px';
    selectBox.style.display = 'block';
  }
});

document.addEventListener('mouseup', (e) => {
  if (e.button !== 0 || !isDragSelecting) return;
  isDragSelecting = false;
  if (dragMoved) {
    const x1 = Math.min(e.clientX, dragStartX);
    const y1 = Math.min(e.clientY, dragStartY);
    const x2 = Math.max(e.clientX, dragStartX);
    const y2 = Math.max(e.clientY, dragStartY);
    const camDist = camera.position.distanceTo(controls.target);
    const maxSelectDist = camDist * 3;
    if (!e.shiftKey) selectedStarIds.clear();
    for (const sprite of starGroup.children) {
      const pos = sprite.position.clone().project(camera);
      // Skip stars behind camera
      if (pos.z > 1) continue;
      const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
      const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
      if (screenX >= x1 && screenX <= x2 && screenY >= y1 && screenY <= y2) {
        if (camera.position.distanceTo(sprite.position) <= maxSelectDist) {
          selectedStarIds.add(sprite.userData.starId);
        }
      }
    }
    highlightStarInList();
    selectBox.style.display = 'none';
  }
});

// Left-click: measure mode selection OR star selection
renderer.domElement.addEventListener('click', (e) => {
  if (dragMoved) return;
  if (!measureMode) {
    // Star selection in 3D view
    const star = getIntersectedStar(e);
    if (star) {
      if (e.shiftKey) {
        // Shift+click: toggle in multi-selection
        if (selectedStarIds.has(star.id)) selectedStarIds.delete(star.id);
        else selectedStarIds.add(star.id);
      } else {
        // Normal click: single select/deselect
        if (selectedStarIds.size === 1 && selectedStarIds.has(star.id)) {
          selectedStarIds.clear();
        } else {
          selectedStarIds.clear();
          selectedStarIds.add(star.id);
        }
      }
      highlightStarInList();
    } else {
      // Clicked empty space — deselect all
      selectedStarIds.clear();
      highlightStarInList();
    }
    return;
  }

  let sel = null;
  // Check planets first (smaller targets)
  const planet = getIntersectedPlanet(e);
  if (planet) {
    sel = { type: 'planet', id: planet.id };
  } else {
    const star = getIntersectedStar(e);
    if (star) {
      sel = { type: 'star', id: star.id };
    }
  }
  if (!sel) {
    // Clicked empty space — clear selection and any existing measurement
    measureSelection = [];
    clearMeasureLine();
    return;
  }

  // Don't select the same object twice
  if (measureSelection.length > 0) {
    const prev = measureSelection[0];
    if (prev.type === sel.type && prev.id === sel.id) return;
  }
  measureSelection.push(sel);

  if (measureSelection.length === 2) {
    drawMeasureLine(measureSelection[0], measureSelection[1]);
    measureSelection = [];
    setMeasureMode(false);
  }
});

// Double-click: open solar system popup
renderer.domElement.addEventListener('dblclick', (e) => {
  const star = getIntersectedStar(e);
  if (star) openSolarSystemPopup(star);
});

// ── Star Context Menu (right-click) ──────────────────
const ctxMenu = document.getElementById('star-context-menu');
const multiCtxMenu = document.getElementById('multi-context-menu');
let ctxStarId = null;

function closeContextMenu() {
  ctxMenu.style.display = 'none';
  multiCtxMenu.style.display = 'none';
  document.getElementById('ctx-zone-submenu').style.display = 'none';
  ctxStarId = null;
}

function showMenuAt(menu, x, y) {
  menu.style.display = 'block';
  const mx = Math.min(x, window.innerWidth - 180);
  const my = Math.min(y, window.innerHeight - 120);
  menu.style.left = mx + 'px';
  menu.style.top = my + 'px';
}

renderer.domElement.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  closeContextMenu();

  if (selectedStarIds.size > 1) {
    // Multi-select context menu
    showMenuAt(multiCtxMenu, e.clientX, e.clientY);
  } else {
    const star = getIntersectedStar(e);
    if (star) {
      ctxStarId = star.id;
      showMenuAt(ctxMenu, e.clientX, e.clientY);
    }
  }
});

// Single star menu actions
document.getElementById('ctx-view-system').addEventListener('click', () => {
  const star = stars.find(s => s.id === ctxStarId);
  closeContextMenu();
  if (star) openSolarSystemPopup(star);
});

document.getElementById('ctx-delete-star').addEventListener('click', () => {
  const star = stars.find(s => s.id === ctxStarId);
  closeContextMenu();
  if (star) {
    if (confirm(`Delete star "${star.name}"?`)) removeStar(star.id);
  }
});

// Multi-select menu actions
document.getElementById('ctx-multi-add-zone').addEventListener('click', () => {
  const submenu = document.getElementById('ctx-zone-submenu');
  if (submenu.style.display === 'block') {
    submenu.style.display = 'none';
    return;
  }
  submenu.innerHTML = '';
  if (zones.length === 0) {
    submenu.innerHTML = '<div style="padding:5px 14px; font-size:11px; color:#667799;">No zones created</div>';
  } else {
    for (const zone of zones) {
      const colorInfo = ZONE_COLORS[zone.color] || ZONE_COLORS.gray;
      const opt = document.createElement('div');
      opt.className = 'ctx-zone-option';
      opt.innerHTML = `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${colorInfo.css};margin-right:6px;vertical-align:middle;"></span>${zone.name}`;
      opt.addEventListener('click', () => {
        for (const starId of selectedStarIds) {
          const star = stars.find(s => s.id === starId);
          if (!star) continue;
          if (!star.zoneIds) star.zoneIds = [];
          // Add to zone (multi-zone: don't remove from existing)
          if (!star.zoneIds.includes(zone.id)) star.zoneIds.push(zone.id);
          if (!zone.starIds.includes(starId)) zone.starIds.push(starId);
        }
        rebuildZoneMeshes();
        updateStarList();
        updateZoneList();
        saveToLocalStorage();
        closeContextMenu();
      });
      submenu.appendChild(opt);
    }
  }
  submenu.style.display = 'block';
});

document.getElementById('ctx-multi-delete').addEventListener('click', () => {
  const count = selectedStarIds.size;
  closeContextMenu();
  if (confirm(`Delete ${count} selected star${count !== 1 ? 's' : ''}?`)) {
    const ids = Array.from(selectedStarIds);
    for (const id of ids) removeStar(id);
    selectedStarIds.clear();
    highlightStarInList();
  }
});

// Close context menu on any other click (but not clicks inside the menus)
multiCtxMenu.addEventListener('click', (e) => e.stopPropagation());
document.addEventListener('click', closeContextMenu);
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeContextMenu(); });

// ── Edit Modal ───────────────────────────────────────
function openEditModal(star) {
  document.getElementById('edit-star-id').value = star.id;
  document.getElementById('edit-star-name').value = star.name;
  document.getElementById('edit-star-x').value = star.x;
  document.getElementById('edit-star-y').value = star.y;
  document.getElementById('edit-star-z').value = star.z;
  const starSizeVal = star.size || DEFAULT_STAR_SIZE;
  document.getElementById('edit-star-size').value = sizeToSlider(starSizeVal);
  document.getElementById('edit-star-size-value').textContent = formatSize(starSizeVal);

  const zonesContainer = document.getElementById('edit-star-zones');
  zonesContainer.innerHTML = '';
  if (zones.length === 0) {
    zonesContainer.innerHTML = '<div style="color:#667799; font-size:11px;">No zones created</div>';
  } else {
    for (const z of zones) {
      const colorInfo = ZONE_COLORS[z.color] || ZONE_COLORS.gray;
      const checked = (star.zoneIds || []).includes(z.id) ? 'checked' : '';
      const label = document.createElement('label');
      label.style.cssText = 'display:flex; align-items:center; gap:6px; padding:2px 0; cursor:pointer; font-size:12px; color:#ddeeff;';
      label.innerHTML = `<input type="checkbox" value="${z.id}" ${checked}><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${colorInfo.css};"></span>${z.name}`;
      zonesContainer.appendChild(label);
    }
  }

  const folderSel = document.getElementById('edit-star-folder');
  folderSel.innerHTML = '<option value="">None</option>';
  for (const f of starFolders) {
    const opt = document.createElement('option');
    opt.value = f.id;
    opt.textContent = f.name;
    if (star.folderId === f.id) opt.selected = true;
    folderSel.appendChild(opt);
  }

  populateStarPlanetList(star);
  document.getElementById('edit-overlay').classList.add('visible');
  document.getElementById('edit-star-name').focus();
}

function populateStarPlanetList(star) {
  const listEl = document.getElementById('edit-star-planet-list');
  listEl.innerHTML = '';
  const starPlanets = planets.filter(p => p.starId === star.id);
  if (starPlanets.length === 0) {
    listEl.innerHTML = '<div class="planet-list-empty">No planets</div>';
    return;
  }
  for (const planet of starPlanets) {
    const classInfo = PLANET_CLASSIFICATIONS[planet.classification] || PLANET_CLASSIFICATIONS.terrestrial;
    const entry = document.createElement('div');
    entry.className = 'planet-entry';
    entry.innerHTML = `
      <span><span class="planet-class-dot" style="background:${classInfo.css}"></span>${planet.name} <span style="color:#667799; font-size:11px;">${planet.orbitalRadius} AU</span></span>
      <span class="remove-planet">Remove</span>
    `;
    entry.querySelector('.remove-planet').addEventListener('click', () => {
      removePlanet(planet.id);
      populateStarPlanetList(star);
    });
    entry.addEventListener('dblclick', () => {
      closeEditModal();
      openEditPlanetModal(planet);
    });
    listEl.appendChild(entry);
  }
}

// ── Add Planet Modal ─────────────────────────────────
function openAddPlanetModal(starId) {
  document.getElementById('add-planet-star-id').value = starId;
  document.getElementById('add-planet-name').value = '';
  document.getElementById('add-planet-radius').value = '';
  document.getElementById('add-planet-angle').value = '';
  document.getElementById('add-planet-class').value = 'terrestrial';
  const addPlanetDefault = PLANET_CLASSIFICATIONS.terrestrial.defaultSize;
  document.getElementById('add-planet-size').value = sizeToSlider(addPlanetDefault);
  document.getElementById('add-planet-size-value').textContent = formatSize(addPlanetDefault);
  document.getElementById('add-planet-overlay').classList.add('visible');
  document.getElementById('add-planet-name').focus();
}

function closeAddPlanetModal() {
  document.getElementById('add-planet-overlay').classList.remove('visible');
}

// ── Size slider initialization ──────────────────────
initSizeSlider('edit-star-size', 'edit-star-size-value');
initSizeSlider('add-planet-size', 'add-planet-size-value');
initSizeSlider('edit-planet-size', 'edit-planet-size-value');
initSizeSlider('add-moon-size', 'add-moon-size-value');
initSizeSlider('edit-moon-size', 'edit-moon-size-value');

// Update add-planet slider when classification changes
document.getElementById('add-planet-class').addEventListener('change', () => {
  const cls = document.getElementById('add-planet-class').value;
  const defaultSize = (PLANET_CLASSIFICATIONS[cls] || PLANET_CLASSIFICATIONS.terrestrial).defaultSize;
  const slider = document.getElementById('add-planet-size');
  slider.value = sizeToSlider(defaultSize);
  document.getElementById('add-planet-size-value').textContent = formatSize(defaultSize);
});

document.getElementById('btn-solar-add-planet').addEventListener('click', () => {
  openAddPlanetModal(solarSystemStarId);
});

document.getElementById('add-planet-close').addEventListener('click', closeAddPlanetModal);

document.getElementById('add-planet-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('add-planet-overlay')) closeAddPlanetModal();
});

document.getElementById('btn-add-planet').addEventListener('click', () => {
  const starId = parseInt(document.getElementById('add-planet-star-id').value);
  const name = document.getElementById('add-planet-name').value.trim();
  const radius = document.getElementById('add-planet-radius').value;
  const angle = document.getElementById('add-planet-angle').value;
  const classification = document.getElementById('add-planet-class').value;

  if (!name) { alert('Please enter a planet name.'); return; }
  if (radius === '' || angle === '') { alert('Please enter orbital radius and angle.'); return; }
  const rn = parseFloat(radius);
  if (isNaN(rn) || rn <= 0) { alert('Orbital radius must be greater than 0.'); return; }

  const size = sliderToSize(document.getElementById('add-planet-size').value);
  addPlanet(name, starId, rn, parseFloat(angle) || 0, classification, size);
  closeAddPlanetModal();
  redrawSolarSystem();
});

// ── Edit Planet Modal ────────────────────────────────
function openEditPlanetModal(planet) {
  document.getElementById('edit-planet-id').value = planet.id;
  document.getElementById('edit-planet-name').value = planet.name;
  document.getElementById('edit-planet-radius').value = planet.orbitalRadius;
  document.getElementById('edit-planet-angle').value = planet.orbitalAngle;
  document.getElementById('edit-planet-class').value = planet.classification;
  const editPlanetSizeVal = planet.size || PLANET_CLASSIFICATIONS[planet.classification]?.defaultSize || 0.0000426;
  document.getElementById('edit-planet-size').value = sizeToSlider(editPlanetSizeVal);
  document.getElementById('edit-planet-size-value').textContent = formatSize(editPlanetSizeVal);
  populatePlanetMoonList(planet);
  document.getElementById('edit-planet-overlay').classList.add('visible');
  document.getElementById('edit-planet-name').focus();
}

function populatePlanetMoonList(planet) {
  const listEl = document.getElementById('edit-planet-moon-list');
  listEl.innerHTML = '';
  const planetMoons = moons.filter(m => m.planetId === planet.id);
  if (planetMoons.length === 0) {
    listEl.innerHTML = '<div class="moon-list-empty">No moons</div>';
    return;
  }
  for (const moon of planetMoons) {
    const entry = document.createElement('div');
    entry.className = 'moon-entry';
    entry.innerHTML = `
      <span><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:#bbccdd;margin-right:5px;vertical-align:middle;"></span>${moon.name} <span style="color:#667799; font-size:11px;">${moon.orbitalRadius} AU</span></span>
      <span class="remove-moon">Remove</span>
    `;
    entry.querySelector('.remove-moon').addEventListener('click', () => {
      removeMoon(moon.id);
      populatePlanetMoonList(planet);
    });
    entry.addEventListener('dblclick', () => {
      closeEditPlanetModal();
      openEditMoonModal(moon);
    });
    listEl.appendChild(entry);
  }
}

function closeEditPlanetModal() {
  document.getElementById('edit-planet-overlay').classList.remove('visible');
}

document.getElementById('btn-edit-planet-save').addEventListener('click', () => {
  const id = parseInt(document.getElementById('edit-planet-id').value);
  const name = document.getElementById('edit-planet-name').value.trim();
  const radius = document.getElementById('edit-planet-radius').value;
  const angle = document.getElementById('edit-planet-angle').value;
  const classification = document.getElementById('edit-planet-class').value;

  if (!name) { alert('Please enter a planet name.'); return; }
  if (radius === '') { alert('Please enter orbital radius.'); return; }
  const rn = parseFloat(radius);
  if (isNaN(rn) || rn <= 0) { alert('Orbital radius must be greater than 0.'); return; }

  const size = sliderToSize(document.getElementById('edit-planet-size').value);
  updatePlanet(id, name, rn, parseFloat(angle) || 0, classification, size);
  closeEditPlanetModal();
});

document.getElementById('btn-edit-planet-cancel').addEventListener('click', closeEditPlanetModal);

document.getElementById('btn-edit-planet-delete').addEventListener('click', () => {
  const id = parseInt(document.getElementById('edit-planet-id').value);
  const planet = planets.find(p => p.id === id);
  if (!planet || !confirm(`Delete planet "${planet.name}"?`)) return;
  removePlanet(id);
  closeEditPlanetModal();
  redrawSolarSystem();
});

document.getElementById('edit-planet-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('edit-planet-overlay')) closeEditPlanetModal();
});

document.getElementById('btn-edit-planet-add-moon').addEventListener('click', () => {
  const planetId = parseInt(document.getElementById('edit-planet-id').value);
  closeEditPlanetModal();
  openAddMoonModal(planetId);
});

// ── Add Moon Modal ──────────────────────────────────
function openAddMoonModal(planetId) {
  document.getElementById('add-moon-planet-id').value = planetId;
  document.getElementById('add-moon-name').value = '';
  document.getElementById('add-moon-radius').value = '';
  document.getElementById('add-moon-angle').value = '';
  document.getElementById('add-moon-size').value = sizeToSlider(DEFAULT_MOON_SIZE);
  document.getElementById('add-moon-size-value').textContent = formatSize(DEFAULT_MOON_SIZE);
  document.getElementById('add-moon-overlay').classList.add('visible');
  document.getElementById('add-moon-name').focus();
}

function closeAddMoonModal() {
  document.getElementById('add-moon-overlay').classList.remove('visible');
}

document.getElementById('add-moon-close').addEventListener('click', closeAddMoonModal);

document.getElementById('add-moon-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('add-moon-overlay')) closeAddMoonModal();
});

document.getElementById('btn-add-moon').addEventListener('click', () => {
  const planetId = parseInt(document.getElementById('add-moon-planet-id').value);
  const name = document.getElementById('add-moon-name').value.trim();
  const radius = document.getElementById('add-moon-radius').value;
  const angle = document.getElementById('add-moon-angle').value;
  const size = sliderToSize(document.getElementById('add-moon-size').value);

  if (!name) { alert('Please enter a moon name.'); return; }
  if (radius === '') { alert('Please enter orbital radius.'); return; }
  const rn = parseFloat(radius);
  if (isNaN(rn) || rn <= 0) { alert('Orbital radius must be greater than 0.'); return; }

  addMoon(name, planetId, rn, parseFloat(angle) || 0, size);
  closeAddMoonModal();
  redrawSolarSystem();
});

// ── Edit Moon Modal ─────────────────────────────────
function openEditMoonModal(moon) {
  document.getElementById('edit-moon-id').value = moon.id;
  document.getElementById('edit-moon-name').value = moon.name;
  document.getElementById('edit-moon-radius').value = moon.orbitalRadius;
  document.getElementById('edit-moon-angle').value = moon.orbitalAngle;
  const editMoonSizeVal = moon.size || DEFAULT_MOON_SIZE;
  document.getElementById('edit-moon-size').value = sizeToSlider(editMoonSizeVal);
  document.getElementById('edit-moon-size-value').textContent = formatSize(editMoonSizeVal);
  document.getElementById('edit-moon-overlay').classList.add('visible');
  document.getElementById('edit-moon-name').focus();
}

function closeEditMoonModal() {
  document.getElementById('edit-moon-overlay').classList.remove('visible');
}

document.getElementById('btn-edit-moon-save').addEventListener('click', () => {
  const id = parseInt(document.getElementById('edit-moon-id').value);
  const name = document.getElementById('edit-moon-name').value.trim();
  const radius = document.getElementById('edit-moon-radius').value;
  const angle = document.getElementById('edit-moon-angle').value;
  const size = sliderToSize(document.getElementById('edit-moon-size').value);

  if (!name) { alert('Please enter a moon name.'); return; }
  if (radius === '') { alert('Please enter orbital radius.'); return; }
  const rn = parseFloat(radius);
  if (isNaN(rn) || rn <= 0) { alert('Orbital radius must be greater than 0.'); return; }

  updateMoon(id, name, rn, parseFloat(angle) || 0, size);
  closeEditMoonModal();
  redrawSolarSystem();
});

document.getElementById('btn-edit-moon-cancel').addEventListener('click', closeEditMoonModal);

document.getElementById('btn-edit-moon-delete').addEventListener('click', () => {
  const id = parseInt(document.getElementById('edit-moon-id').value);
  const moon = moons.find(m => m.id === id);
  if (!moon || !confirm(`Delete moon "${moon.name}"?`)) return;
  removeMoon(id);
  closeEditMoonModal();
  redrawSolarSystem();
});

document.getElementById('edit-moon-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('edit-moon-overlay')) closeEditMoonModal();
});

function closeEditModal() {
  document.getElementById('edit-overlay').classList.remove('visible');
}

document.getElementById('btn-edit-save').addEventListener('click', () => {
  const id = parseInt(document.getElementById('edit-star-id').value);
  const name = document.getElementById('edit-star-name').value.trim();
  const x = document.getElementById('edit-star-x').value;
  const y = document.getElementById('edit-star-y').value;
  const z = document.getElementById('edit-star-z').value;
  const zoneCheckboxes = document.querySelectorAll('#edit-star-zones input[type="checkbox"]:checked');
  const newZoneIds = [...zoneCheckboxes].map(cb => parseInt(cb.value));
  const folderVal = document.getElementById('edit-star-folder').value;
  const folderId = folderVal ? parseInt(folderVal) : null;

  if (!name) { alert('Please enter a star name.'); return; }
  if (x === '' || y === '' || z === '') { alert('Please enter all coordinates.'); return; }
  const xn = parseFloat(x), yn = parseFloat(y), zn = parseFloat(z);
  if ([xn, yn, zn].some(v => isNaN(v) || v < 0 || v > UNIVERSE_SIZE)) {
    alert(`Coordinates must be between 0 and ${UNIVERSE_SIZE}.`);
    return;
  }

  const size = sliderToSize(document.getElementById('edit-star-size').value) || DEFAULT_STAR_SIZE;
  updateStar(id, name, xn, yn, zn, newZoneIds, size, folderId);
  closeEditModal();
});

document.getElementById('btn-edit-cancel').addEventListener('click', closeEditModal);

document.getElementById('edit-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('edit-overlay')) closeEditModal();
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const editOpen = document.getElementById('edit-overlay').classList.contains('visible');
    const planetEditOpen = document.getElementById('edit-planet-overlay').classList.contains('visible');
    const zoneEditOpen = document.getElementById('edit-zone-overlay').classList.contains('visible');
    const bulkOpen = document.getElementById('bulk-add-overlay').classList.contains('visible');
    const addPlanetOpen = document.getElementById('add-planet-overlay').classList.contains('visible');
    const addMoonOpen = document.getElementById('add-moon-overlay').classList.contains('visible');
    const editMoonOpen = document.getElementById('edit-moon-overlay').classList.contains('visible');
    if (addMoonOpen) {
      closeAddMoonModal();
    } else if (editMoonOpen) {
      closeEditMoonModal();
    } else if (addPlanetOpen) {
      closeAddPlanetModal();
    } else if (editOpen || planetEditOpen || zoneEditOpen || bulkOpen) {
      closeEditModal(); closeEditZoneModal(); closeEditPlanetModal(); closeBulkAddModal();
    } else if (solarSystemStarId !== null) {
      closeSolarSystemPopup();
    }
  }
});

// ── Edit Zone Modal ──────────────────────────────────
function openEditZoneModal(zone) {
  document.getElementById('edit-zone-id').value = zone.id;
  document.getElementById('edit-zone-name').value = zone.name;
  document.getElementById('edit-zone-color').value = zone.color;
  populateEditZoneStarList(zone);
  document.getElementById('edit-zone-overlay').classList.add('visible');
  document.getElementById('edit-zone-name').focus();
}

function populateEditZoneStarList(zone) {
  const listEl = document.getElementById('edit-zone-star-list');
  listEl.innerHTML = '';
  const zoneStars = stars.filter(s => zone.starIds.includes(s.id));
  if (zoneStars.length === 0) {
    listEl.innerHTML = '<div class="zone-star-empty">No stars in this zone</div>';
    return;
  }
  for (const star of zoneStars) {
    const entry = document.createElement('div');
    entry.className = 'zone-star-entry';
    entry.innerHTML = `
      <span>${star.name} <span style="color:#667799; font-size:11px;">(${formatCoord(star.x)}, ${formatCoord(star.y)}, ${formatCoord(star.z)})</span></span>
      <span class="remove-from-zone">Remove</span>
    `;
    entry.querySelector('.remove-from-zone').addEventListener('click', () => {
      // Remove star from zone
      zone.starIds = zone.starIds.filter(sid => sid !== star.id);
      if (star.zoneIds) star.zoneIds = star.zoneIds.filter(zid => zid !== zone.id);
      populateEditZoneStarList(zone);
      rebuildZoneMeshes();
      updateStarList();
      updateZoneList();
      saveToLocalStorage();
    });
    listEl.appendChild(entry);
  }
}

function closeEditZoneModal() {
  document.getElementById('edit-zone-overlay').classList.remove('visible');
}

document.getElementById('btn-edit-zone-save').addEventListener('click', () => {
  const id = parseInt(document.getElementById('edit-zone-id').value);
  const name = document.getElementById('edit-zone-name').value.trim();
  const color = document.getElementById('edit-zone-color').value;
  if (!name) { alert('Please enter a zone name.'); return; }

  const zone = zones.find(z => z.id === id);
  if (zone) {
    zone.name = name;
    zone.color = color;
    rebuildZoneMeshes();
    updateZoneList();
    updateZoneDropdowns();
    updateStarList();
    saveToLocalStorage();
  }
  closeEditZoneModal();
});

document.getElementById('btn-edit-zone-cancel').addEventListener('click', closeEditZoneModal);

document.getElementById('edit-zone-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('edit-zone-overlay')) closeEditZoneModal();
});

// ── Solar System Popup ───────────────────────────────
let solarSystemStarId = null;
let solarSystemPlanetPositions = []; // [{planet, cx, cy, radius}] for hit detection
let solarSystemMoonPositions = [];   // [{moon, cx, cy, radius}] for hit detection
let ssZoom = 1;
let ssPanX = 0, ssPanY = 0;
let ssIsDragging = false, ssDragStartX = 0, ssDragStartY = 0, ssPanStartX = 0, ssPanStartY = 0;

function openSolarSystemPopup(star) {
  solarSystemStarId = star.id;
  ssZoom = 1;
  ssPanX = 0;
  ssPanY = 0;
  document.getElementById('solar-system-title').textContent = `${star.name} System`;
  document.getElementById('solar-system-overlay').classList.add('visible');
  drawSolarSystem(star);
}

function closeSolarSystemPopup() {
  document.getElementById('solar-system-overlay').classList.remove('visible');
  solarSystemStarId = null;
  solarSystemPlanetPositions = [];
  solarSystemMoonPositions = [];
}

function redrawSolarSystem() {
  const star = stars.find(s => s.id === solarSystemStarId);
  if (star) drawSolarSystem(star);
}

function drawSolarSystem(star) {
  const canvas = document.getElementById('solar-system-canvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  const baseCX = w / 2, baseCY = h / 2;
  const centerX = baseCX + ssPanX, centerY = baseCY + ssPanY;
  const starPlanets = planets.filter(p => p.starId === star.id);
  solarSystemPlanetPositions = [];
  solarSystemMoonPositions = [];

  // Find max orbital radius for scaling
  const maxRadius = starPlanets.length > 0
    ? Math.max(...starPlanets.map(p => p.orbitalRadius))
    : 1;
  const baseScale = Math.min(w, h) * 0.4 / maxRadius;
  const scale = baseScale * ssZoom;

  // Draw orbit circles
  for (const planet of starPlanets) {
    const orbitR = planet.orbitalRadius * scale;
    ctx.beginPath();
    ctx.arc(centerX, centerY, orbitR, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(100, 160, 255, 0.45)';
    ctx.setLineDash([6, 4]);
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.setLineDash([]);

    // Orbit radius label
    ctx.font = '9px Arial';
    ctx.fillStyle = 'rgba(100, 160, 255, 0.6)';
    ctx.textAlign = 'left';
    ctx.fillText(`${planet.orbitalRadius} AU`, centerX + orbitR + 4, centerY - 2);
  }

  // Body size scale: exaggerated so bodies are visible, but proportional to each other
  // Base: star radius maps to ~12px at 1x zoom, everything else relative
  const starSize = star.size || DEFAULT_STAR_SIZE;
  const bodyScale = 12 / starSize; // pixels per AU of body radius at 1x zoom

  // Draw star
  const starR = Math.max(4, starSize * bodyScale * Math.min(ssZoom, 4));
  const starGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, starR);
  starGrad.addColorStop(0, '#ffffff');
  starGrad.addColorStop(0.4, '#ffdd88');
  starGrad.addColorStop(1, 'rgba(255, 200, 80, 0)');
  ctx.beginPath();
  ctx.arc(centerX, centerY, starR, 0, Math.PI * 2);
  ctx.fillStyle = starGrad;
  ctx.fill();

  // Draw star name and size
  ctx.font = '11px Arial';
  ctx.fillStyle = '#ffdd88';
  ctx.textAlign = 'center';
  ctx.fillText(star.name, centerX, centerY + starR + 14);
  ctx.font = '9px Arial';
  ctx.fillStyle = '#667799';
  ctx.fillText(`r: ${starSize} AU`, centerX, centerY + starR + 26);

  // Draw planets
  for (const planet of starPlanets) {
    const classInfo = PLANET_CLASSIFICATIONS[planet.classification] || PLANET_CLASSIFICATIONS.terrestrial;
    const pSize = planet.size || classInfo.defaultSize;
    const planetR = Math.max(3, pSize * bodyScale * Math.min(ssZoom, 4));
    const orbitR = planet.orbitalRadius * scale;
    const angleRad = (planet.orbitalAngle * Math.PI) / 180;
    const px = centerX + Math.cos(angleRad) * orbitR;
    const py = centerY - Math.sin(angleRad) * orbitR; // canvas Y is inverted

    // Planet glow
    const glowR = planetR * 1.8;
    const grad = ctx.createRadialGradient(px, py, 0, px, py, glowR);
    grad.addColorStop(0, classInfo.css);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.beginPath();
    ctx.arc(px, py, glowR, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();

    // Solid planet circle
    ctx.beginPath();
    ctx.arc(px, py, planetR, 0, Math.PI * 2);
    ctx.fillStyle = classInfo.css;
    ctx.fill();

    // Planet name and info
    ctx.font = '11px Arial';
    ctx.fillStyle = '#ddeeff';
    ctx.textAlign = 'center';
    ctx.fillText(planet.name, px, py - glowR - 4);
    ctx.font = '9px Arial';
    ctx.fillStyle = '#667799';
    ctx.fillText(`${planet.orbitalRadius} AU · ${classInfo.label} · r: ${pSize} AU`, px, py + glowR + 12);

    // Store position for hit detection
    solarSystemPlanetPositions.push({ planet, cx: px, cy: py, radius: Math.max(glowR, 8) });

    // Draw moons orbiting this planet
    const planetMoons = moons.filter(m => m.planetId === planet.id);
    for (const moon of planetMoons) {
      const moonOrbitR = moon.orbitalRadius * scale;
      // Dashed orbit circle around planet
      ctx.beginPath();
      ctx.arc(px, py, moonOrbitR, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(180, 200, 220, 0.3)';
      ctx.setLineDash([3, 3]);
      ctx.lineWidth = 0.8;
      ctx.stroke();
      ctx.setLineDash([]);

      const moonAngleRad = (moon.orbitalAngle * Math.PI) / 180;
      const mx = px + Math.cos(moonAngleRad) * moonOrbitR;
      const my = py - Math.sin(moonAngleRad) * moonOrbitR;
      const moonSize = moon.size || DEFAULT_MOON_SIZE;
      const moonR = Math.max(2, moonSize * bodyScale * Math.min(ssZoom, 4));

      // Moon circle
      ctx.beginPath();
      ctx.arc(mx, my, moonR, 0, Math.PI * 2);
      ctx.fillStyle = '#bbccdd';
      ctx.fill();

      // Moon name
      ctx.font = '9px Arial';
      ctx.fillStyle = '#99aabb';
      ctx.textAlign = 'center';
      ctx.fillText(moon.name, mx, my - moonR - 3);

      // Store for hit detection
      solarSystemMoonPositions.push({ moon, cx: mx, cy: my, radius: Math.max(moonR, 6) });
    }
  }

  // "No planets" message
  if (starPlanets.length === 0) {
    ctx.font = '14px Arial';
    ctx.fillStyle = '#556677';
    ctx.textAlign = 'center';
    ctx.fillText('No planets — use Edit Solar System to add planets', baseCX, baseCY + 60);
  }

  // Zoom indicator
  ctx.font = '10px Arial';
  ctx.fillStyle = 'rgba(100, 140, 255, 0.4)';
  ctx.textAlign = 'left';
  ctx.fillText(`${ssZoom.toFixed(1)}x`, 8, h - 8);
}

// Canvas mouse coordinates helper
function ssCanvasCoords(e) {
  const canvas = document.getElementById('solar-system-canvas');
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * (canvas.width / rect.width),
    y: (e.clientY - rect.top) * (canvas.height / rect.height)
  };
}

// Zoom with scroll wheel
document.getElementById('solar-system-canvas').addEventListener('wheel', (e) => {
  e.preventDefault();
  const zoomFactor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
  const oldZoom = ssZoom;
  ssZoom = Math.max(0.2, Math.min(50, ssZoom * zoomFactor));

  // Zoom toward mouse position
  const { x: mx, y: my } = ssCanvasCoords(e);
  const canvas = document.getElementById('solar-system-canvas');
  const baseCX = canvas.width / 2, baseCY = canvas.height / 2;
  const ratio = ssZoom / oldZoom;
  ssPanX = mx - baseCX - ratio * (mx - baseCX - ssPanX);
  ssPanY = my - baseCY - ratio * (my - baseCY - ssPanY);

  redrawSolarSystem();
}, { passive: false });

// Pan with click-drag
document.getElementById('solar-system-canvas').addEventListener('mousedown', (e) => {
  if (e.button === 0) {
    ssIsDragging = true;
    ssDragStartX = e.clientX;
    ssDragStartY = e.clientY;
    ssPanStartX = ssPanX;
    ssPanStartY = ssPanY;
    e.preventDefault();
  }
});

document.addEventListener('mousemove', (e) => {
  if (!ssIsDragging) return;
  const canvas = document.getElementById('solar-system-canvas');
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  ssPanX = ssPanStartX + (e.clientX - ssDragStartX) * scaleX;
  ssPanY = ssPanStartY + (e.clientY - ssDragStartY) * scaleY;
  redrawSolarSystem();
});

document.addEventListener('mouseup', () => {
  ssIsDragging = false;
});

// Double-click on moon or planet in solar system canvas
document.getElementById('solar-system-canvas').addEventListener('dblclick', (e) => {
  const { x: mx, y: my } = ssCanvasCoords(e);

  // Check moons first (smaller targets, need priority)
  for (const mp of solarSystemMoonPositions) {
    const dx = mx - mp.cx, dy = my - mp.cy;
    if (dx * dx + dy * dy <= mp.radius * mp.radius) {
      openEditMoonModal(mp.moon);
      return;
    }
  }

  for (const pp of solarSystemPlanetPositions) {
    const dx = mx - pp.cx, dy = my - pp.cy;
    if (dx * dx + dy * dy <= pp.radius * pp.radius) {
      openEditPlanetModal(pp.planet);
      return;
    }
  }
});

// Edit Solar System button in solar system popup
document.getElementById('btn-solar-recenter').addEventListener('click', () => {
  ssZoom = 1;
  ssPanX = 0;
  ssPanY = 0;
  redrawSolarSystem();
});

document.getElementById('btn-solar-edit-star').addEventListener('click', () => {
  const star = stars.find(s => s.id === solarSystemStarId);
  if (star) openEditModal(star);
});

// Close solar system popup
document.getElementById('solar-system-close').addEventListener('click', closeSolarSystemPopup);
document.getElementById('solar-system-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('solar-system-overlay')) closeSolarSystemPopup();
});

// ── Measure Mode ─────────────────────────────────────
function setMeasureMode(on) {
  measureMode = on;
  measureSelection = [];
  document.getElementById('btn-measure').style.display = on ? 'none' : '';
  document.getElementById('btn-cancel-measure').style.display = on ? '' : 'none';
  document.getElementById('measure-instructions').style.display = on ? 'block' : 'none';
  if (on) {
    document.getElementById('btn-measure').classList.add('active');
  } else {
    document.getElementById('btn-measure').classList.remove('active');
  }
}

document.getElementById('btn-measure').addEventListener('click', () => setMeasureMode(true));

// ── Unit Toggle ──────────────────────────────────────
document.getElementById('btn-unit-toggle').addEventListener('click', () => {
  displayUnit = displayUnit === 'ly' ? 'au' : 'ly';
  document.getElementById('btn-unit-toggle').textContent = `Units: ${unitLabel()}`;
  // Refresh all displays that show coordinates/distances
  updateStarList();
  // Rebuild labels (they show in 3D)
  rebuildStarMeshes();
  rebuildPlanetMeshes();
  // If a measurement line exists, redraw it
  if (measureLine) {
    // Find the two stars from the distance result text
    // Easier: just clear and let user re-measure
    clearMeasureLine();
  }
});
document.getElementById('btn-cancel-measure').addEventListener('click', () => {
  setMeasureMode(false);
  clearMeasureLine();
});

// ── Add Star Button ──────────────────────────────────
document.getElementById('btn-add-star').addEventListener('click', () => {
  const name = document.getElementById('star-name').value.trim();
  const x = document.getElementById('star-x').value;
  const y = document.getElementById('star-y').value;
  const z = document.getElementById('star-z').value;
  const zoneVal = document.getElementById('star-zone').value;
  const zoneId = zoneVal ? parseInt(zoneVal) : null;

  if (x === '' || y === '' || z === '') { alert('Please enter all coordinates.'); return; }
  const xn = parseFloat(x), yn = parseFloat(y), zn = parseFloat(z);
  if ([xn, yn, zn].some(v => isNaN(v) || v < 0 || v > UNIVERSE_SIZE)) {
    alert(`Coordinates must be between 0 and ${UNIVERSE_SIZE}.`);
    return;
  }
  const starName = name || String(nextStarId).padStart(4, '0');
  addStar(starName, xn, yn, zn, zoneId);
  document.getElementById('star-name').value = '';
  document.getElementById('star-x').value = '';
  document.getElementById('star-y').value = '';
  document.getElementById('star-z').value = '';
  document.getElementById('star-zone').value = '';
});

// ── Add Zone Button ──────────────────────────────────
document.getElementById('btn-add-zone').addEventListener('click', () => {
  const name = document.getElementById('zone-name').value.trim();
  const color = document.getElementById('zone-color').value;
  if (!name) { alert('Please enter a zone name.'); return; }
  addZone(name, color);
  document.getElementById('zone-name').value = '';
});

// ── Bulk Add Stars ───────────────────────────────────
function openBulkAddModal() {
  // Populate zone dropdown
  const sel = document.getElementById('bulk-zone');
  sel.innerHTML = '<option value="">None</option>';
  for (const z of zones) {
    const opt = document.createElement('option');
    opt.value = z.id;
    opt.textContent = `${z.name} (${z.color})`;
    sel.appendChild(opt);
  }
  document.getElementById('bulk-status').style.display = 'none';
  document.getElementById('bulk-add-overlay').classList.add('visible');
  document.getElementById('bulk-group-name').focus();
}

function closeBulkAddModal() {
  document.getElementById('bulk-add-overlay').classList.remove('visible');
}

document.getElementById('btn-bulk-add').addEventListener('click', openBulkAddModal);
document.getElementById('btn-bulk-cancel').addEventListener('click', closeBulkAddModal);
document.getElementById('bulk-add-overlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('bulk-add-overlay')) closeBulkAddModal();
});

// Toggle box/sphere fields
document.getElementById('bulk-shape').addEventListener('change', () => {
  const shape = document.getElementById('bulk-shape').value;
  document.getElementById('bulk-box-fields').style.display = shape === 'box' ? '' : 'none';
  document.getElementById('bulk-sphere-fields').style.display = shape === 'sphere' ? '' : 'none';
});

document.getElementById('btn-bulk-generate').addEventListener('click', () => {
  const groupName = document.getElementById('bulk-group-name').value.trim();

  const count = parseInt(document.getElementById('bulk-count').value);
  if (isNaN(count) || count < 1) { alert('Please enter a valid number of stars.'); return; }

  const minDist = parseFloat(document.getElementById('bulk-min-dist').value) || 0;
  const shape = document.getElementById('bulk-shape').value;
  const zoneVal = document.getElementById('bulk-zone').value;
  const zoneId = zoneVal ? parseInt(zoneVal) : null;

  let cx, cy, cz, genPoint;

  if (shape === 'box') {
    cx = parseFloat(document.getElementById('bulk-cx').value);
    cy = parseFloat(document.getElementById('bulk-cy').value);
    cz = parseFloat(document.getElementById('bulk-cz').value);
    const bw = parseFloat(document.getElementById('bulk-w').value);
    const bh = parseFloat(document.getElementById('bulk-h').value);
    const bd = parseFloat(document.getElementById('bulk-d').value);
    if ([cx, cy, cz, bw, bh, bd].some(v => isNaN(v))) { alert('Please fill in all box fields.'); return; }
    if (bw <= 0 || bh <= 0 || bd <= 0) { alert('Box dimensions must be greater than 0.'); return; }
    const hw = bw / 2, hh = bh / 2, hd = bd / 2;
    genPoint = () => ({
      x: cx - hw + Math.random() * bw,
      y: cy - hh + Math.random() * bh,
      z: cz - hd + Math.random() * bd
    });
  } else {
    cx = parseFloat(document.getElementById('bulk-scx').value);
    cy = parseFloat(document.getElementById('bulk-scy').value);
    cz = parseFloat(document.getElementById('bulk-scz').value);
    const sr = parseFloat(document.getElementById('bulk-sr').value);
    if ([cx, cy, cz, sr].some(v => isNaN(v))) { alert('Please fill in all sphere fields.'); return; }
    if (sr <= 0) { alert('Radius must be greater than 0.'); return; }
    genPoint = () => {
      // Uniform random point in sphere
      const u = Math.random();
      const r = sr * Math.cbrt(u);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      return {
        x: cx + r * Math.sin(phi) * Math.cos(theta),
        y: cy + r * Math.sin(phi) * Math.sin(theta),
        z: cz + r * Math.cos(phi)
      };
    };
  }

  const statusEl = document.getElementById('bulk-status');
  statusEl.style.display = 'block';
  statusEl.textContent = 'Generating...';

  const placed = [];
  const maxAttempts = count * 100;
  let attempts = 0;

  while (placed.length < count && attempts < maxAttempts) {
    attempts++;
    const p = genPoint();

    // Clamp to universe bounds
    p.x = Math.max(0, Math.min(UNIVERSE_SIZE, p.x));
    p.y = Math.max(0, Math.min(UNIVERSE_SIZE, p.y));
    p.z = Math.max(0, Math.min(UNIVERSE_SIZE, p.z));

    // Check minimum distance against already placed stars
    if (minDist > 0) {
      let tooClose = false;
      for (const other of placed) {
        const dx = p.x - other.x, dy = p.y - other.y, dz = p.z - other.z;
        if (dx * dx + dy * dy + dz * dz < minDist * minDist) {
          tooClose = true;
          break;
        }
      }
      // Also check existing stars
      if (!tooClose) {
        for (const other of stars) {
          const dx = p.x - other.x, dy = p.y - other.y, dz = p.z - other.z;
          if (dx * dx + dy * dy + dz * dz < minDist * minDist) {
            tooClose = true;
            break;
          }
        }
      }
      if (tooClose) continue;
    }

    placed.push(p);
  }

  if (placed.length === 0) {
    statusEl.textContent = 'Could not place any stars with the given constraints.';
    return;
  }

  // Create folder for group if checkbox is checked
  let bulkFolderId = null;
  if (document.getElementById('bulk-create-folder').checked && placed.length > 0) {
    const newFolder = { id: nextFolderId++, name: groupName || `Group ${nextFolderId - 1}`, collapsed: false };
    starFolders.push(newFolder);
    bulkFolderId = newFolder.id;
  }

  // Add stars in batch (no per-star rebuild)
  for (let i = 0; i < placed.length; i++) {
    const p = placed[i];
    const zoneIds = zoneId ? [zoneId] : [];
    const padded = String(i + 1).padStart(4, '0');
    const starName = groupName ? `${groupName} ${padded}` : String(nextStarId).padStart(4, '0');
    const star = { id: nextStarId++, name: starName, x: p.x, y: p.y, z: p.z, zoneIds, size: DEFAULT_STAR_SIZE, folderId: bulkFolderId };
    stars.push(star);
    if (zoneId) {
      const zone = zones.find(z => z.id === zoneId);
      if (zone && !zone.starIds.includes(star.id)) zone.starIds.push(star.id);
    }
  }
  // Rebuild everything once
  rebuildStarMeshes();
  rebuildZoneMeshes();
  autoAssignStarsToZones();
  updateStarList();
  updateZoneList();
  updateZoneDropdowns();
  saveToLocalStorage();

  statusEl.textContent = `Added ${placed.length} of ${count} stars.`;
  if (placed.length < count) {
    statusEl.textContent += ` Could not place ${count - placed.length} more (min distance constraint).`;
  }
});

// ── Collapsible Panels ───────────────────────────────
document.querySelectorAll('.panel-toggle').forEach(h3 => {
  h3.addEventListener('click', () => {
    const body = document.getElementById(h3.dataset.target);
    h3.classList.toggle('collapsed');
    body.classList.toggle('collapsed');
  });
});

// ── Star List UI ─────────────────────────────────────
function createStarEntry(star) {
  const starZones = (star.zoneIds || []).map(zid => zones.find(z => z.id === zid)).filter(Boolean);
  const entry = document.createElement('div');
  entry.className = 'star-entry';
  entry.dataset.id = star.id;

  let zoneTag = starZones.map(z => {
    const c = ZONE_COLORS[z.color] || ZONE_COLORS.gray;
    return `<span class="star-zone-tag" style="background:${c.css}">${z.name}</span>`;
  }).join('');

  entry.innerHTML = `
    <div>
      <span class="name">${star.name}</span> ${zoneTag}<br>
      <span class="coords">(${formatCoord(star.x)}, ${formatCoord(star.y)}, ${formatCoord(star.z)}) ${unitLabel()}</span>
    </div>
    <span class="delete-star" title="Delete star">&times;</span>
  `;
  entry.addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-star')) return;
    if (e.shiftKey && lastClickedStarId !== null) {
      // Range select: find all star entries in DOM order between anchor and this one
      const allEntries = [...document.querySelectorAll('#star-list .star-entry')];
      const anchorIdx = allEntries.findIndex(el => parseInt(el.dataset.id) === lastClickedStarId);
      const targetIdx = allEntries.findIndex(el => parseInt(el.dataset.id) === star.id);
      if (anchorIdx !== -1 && targetIdx !== -1) {
        const from = Math.min(anchorIdx, targetIdx);
        const to = Math.max(anchorIdx, targetIdx);
        for (let i = from; i <= to; i++) {
          selectedStarIds.add(parseInt(allEntries[i].dataset.id));
        }
      }
    } else if (e.ctrlKey || e.metaKey) {
      // Toggle individual with ctrl/cmd
      if (selectedStarIds.has(star.id)) selectedStarIds.delete(star.id);
      else selectedStarIds.add(star.id);
      lastClickedStarId = star.id;
    } else {
      if (selectedStarIds.size === 1 && selectedStarIds.has(star.id)) {
        selectedStarIds.clear();
        lastClickedStarId = null;
      } else {
        selectedStarIds.clear();
        selectedStarIds.add(star.id);
        lastClickedStarId = star.id;
      }
    }
    highlightStarInList();
    if (selectedStarIds.has(star.id)) {
      controls.target.set(lyToWorld(star.x), lyToWorld(star.y), lyToWorld(star.z));
    }
  });
  entry.addEventListener('dblclick', (e) => {
    if (e.target.classList.contains('delete-star')) return;
    openSolarSystemPopup(star);
  });
  entry.querySelector('.delete-star').addEventListener('click', (e) => {
    e.stopPropagation();
    removeStar(star.id);
  });
  return entry;
}

function updateStarList() {
  const listEl = document.getElementById('star-list');
  const countEl = document.getElementById('star-count');
  countEl.textContent = stars.length;
  listEl.innerHTML = '';
  refreshFolderDropdown();

  const sortedStars = [...stars].sort((a, b) => a.name.localeCompare(b.name));

  // Render folders
  for (const folder of starFolders) {
    const folderStars = sortedStars.filter(s => s.folderId === folder.id);
    const folderDiv = document.createElement('div');
    folderDiv.className = 'star-folder';

    const header = document.createElement('div');
    header.className = 'star-folder-header';
    header.innerHTML = `
      <div>
        <span class="folder-toggle">${folder.collapsed ? '&#9654;' : '&#9660;'}</span>
        ${folder.name}
        <span class="folder-count">(${folderStars.length})</span>
      </div>
      <span class="delete-folder" title="Delete folder">&times;</span>
    `;
    header.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-folder')) return;
      folder.collapsed = !folder.collapsed;
      saveToLocalStorage();
      updateStarList();
    });
    header.addEventListener('dblclick', (e) => {
      if (e.target.classList.contains('delete-folder')) return;
      e.stopPropagation();
      const newName = prompt('Rename folder:', folder.name);
      if (newName && newName.trim()) {
        folder.name = newName.trim();
        saveToLocalStorage();
        updateStarList();
      }
    });
    header.querySelector('.delete-folder').addEventListener('click', (e) => {
      e.stopPropagation();
      // Unassign stars from folder, don't delete the stars
      for (const s of stars) {
        if (s.folderId === folder.id) s.folderId = null;
      }
      starFolders = starFolders.filter(f => f.id !== folder.id);
      saveToLocalStorage();
      updateStarList();
    });
    folderDiv.appendChild(header);

    const contents = document.createElement('div');
    contents.className = 'star-folder-contents' + (folder.collapsed ? ' collapsed' : '');
    for (const star of folderStars) {
      contents.appendChild(createStarEntry(star));
    }
    folderDiv.appendChild(contents);
    listEl.appendChild(folderDiv);
  }

  // Render unfiled stars
  const unfiledStars = sortedStars.filter(s => !s.folderId || !starFolders.find(f => f.id === s.folderId));
  for (const star of unfiledStars) {
    listEl.appendChild(createStarEntry(star));
  }
}

document.getElementById('star-search').addEventListener('input', (e) => {
  const query = e.target.value.toLowerCase();
  const entries = document.querySelectorAll('#star-list .star-entry');
  const folders = document.querySelectorAll('#star-list .star-folder');

  if (!query) {
    entries.forEach(el => el.style.display = '');
    folders.forEach(el => el.style.display = '');
    return;
  }

  entries.forEach(el => {
    const name = el.querySelector('.name')?.textContent.toLowerCase() || '';
    el.style.display = name.includes(query) ? '' : 'none';
  });

  // Hide folders where no stars match
  folders.forEach(folder => {
    const visible = folder.querySelectorAll('.star-entry:not([style*="display: none"])');
    folder.style.display = visible.length ? '' : 'none';
  });
});

function highlightStarInList() {
  document.querySelectorAll('.star-entry').forEach(el => {
    el.classList.toggle('selected', selectedStarIds.has(parseInt(el.dataset.id)));
  });
}

// Add folder button
document.getElementById('btn-add-folder').addEventListener('click', () => {
  const name = prompt('Folder name:');
  if (!name || !name.trim()) return;
  starFolders.push({ id: nextFolderId++, name: name.trim(), collapsed: false });
  saveToLocalStorage();
  updateStarList();
});

// Move-to-folder dropdown
function refreshFolderDropdown() {
  const sel = document.getElementById('move-to-folder-select');
  sel.innerHTML = '<option value="" disabled selected>Move to...</option>';
  const noFolder = document.createElement('option');
  noFolder.value = '__none__';
  noFolder.textContent = '(No folder)';
  sel.appendChild(noFolder);
  for (const f of starFolders) {
    const opt = document.createElement('option');
    opt.value = f.id;
    opt.textContent = f.name;
    sel.appendChild(opt);
  }
}

document.getElementById('move-to-folder-select').addEventListener('change', (e) => {
  const val = e.target.value;
  if (selectedStarIds.size === 0) {
    alert('Select stars first (click or shift-click in the list).');
    e.target.selectedIndex = 0;
    return;
  }
  const folderId = val === '__none__' ? null : parseInt(val);
  for (const sid of selectedStarIds) {
    const star = stars.find(s => s.id === sid);
    if (star) star.folderId = folderId;
  }
  saveToLocalStorage();
  rebuildStarMeshes();
  updateStarList();
  highlightStarInList();
  e.target.selectedIndex = 0; // reset to "Move to..." placeholder
});

// ── Zone List UI ─────────────────────────────────────
function updateZoneList() {
  const listEl = document.getElementById('zone-list');
  listEl.innerHTML = '';
  for (const zone of zones) {
    const colorInfo = ZONE_COLORS[zone.color] || ZONE_COLORS.gray;
    const starCount = zone.starIds.length;
    const entry = document.createElement('div');
    entry.className = 'zone-entry' + (zone.hidden ? ' zone-hidden' : '');
    entry.innerHTML = `
      <div>
        <span class="zone-color-dot" style="background:${colorInfo.css}"></span>
        <span class="zone-name">${zone.name}</span>
        <span class="zone-star-count">(${starCount} star${starCount !== 1 ? 's' : ''})</span>
      </div>
      <div>
        <span class="toggle-zone${zone.hidden ? ' hidden' : ''}" title="${zone.hidden ? 'Show' : 'Hide'} zone">${zone.hidden ? '&#9711;' : '&#9673;'}</span>
        <span class="delete-zone" title="Delete zone">&times;</span>
      </div>
    `;
    entry.querySelector('.toggle-zone').addEventListener('click', (e) => {
      e.stopPropagation();
      zone.hidden = !zone.hidden;
      rebuildZoneMeshes();
      updateZoneList();
      saveToLocalStorage();
    });
    entry.querySelector('.delete-zone').addEventListener('click', () => removeZone(zone.id));
    entry.addEventListener('dblclick', () => openEditZoneModal(zone));
    listEl.appendChild(entry);
  }
}

// ── Zone Dropdowns ───────────────────────────────────
function updateZoneDropdowns() {
  const addSel = document.getElementById('star-zone');
  const currentVal = addSel.value;
  addSel.innerHTML = '<option value="">None</option>';
  for (const z of zones) {
    const opt = document.createElement('option');
    opt.value = z.id;
    opt.textContent = `${z.name} (${z.color})`;
    addSel.appendChild(opt);
  }
  addSel.value = currentVal;
}

// ── Export / Import ──────────────────────────────────
document.getElementById('btn-export').addEventListener('click', () => {
  const data = JSON.stringify({ stars, zones, planets, moons, starFolders }, null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'universe-map.json';
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('btn-import').addEventListener('click', () => {
  document.getElementById('file-input').click();
});

document.getElementById('file-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const imported = JSON.parse(ev.target.result);

      // Map old IDs to new IDs for zone/star/planet references
      const zoneIdMap = {};
      const starIdMap = {};

      if (Array.isArray(imported)) {
        // Simple array of stars
        for (const s of imported) {
          if (s.name && s.x !== undefined && s.y !== undefined && s.z !== undefined) {
            const star = { id: nextStarId++, name: s.name, x: parseFloat(s.x), y: parseFloat(s.y), z: parseFloat(s.z), zoneIds: [], size: parseFloat(s.size) || DEFAULT_STAR_SIZE };
            stars.push(star);
          }
        }
      } else if (imported.stars) {
        // Import zones first
        if (imported.zones && Array.isArray(imported.zones)) {
          for (const z of imported.zones) {
            if (z.name && z.color) {
              const newZone = { id: nextZoneId++, name: z.name, color: z.color, starIds: [], hidden: z.hidden || false };
              zoneIdMap[z.id] = newZone.id;
              zones.push(newZone);
            }
          }
        }
        // Import folders
        if (imported.starFolders && Array.isArray(imported.starFolders)) {
          const folderIdMap = {};
          for (const f of imported.starFolders) {
            const newFolder = { id: nextFolderId++, name: f.name, collapsed: f.collapsed || false };
            folderIdMap[f.id] = newFolder.id;
            starFolders.push(newFolder);
          }
          // Patch folderId references on stars before import
          if (Array.isArray(imported.stars)) {
            for (const s of imported.stars) {
              if (s.folderId) s._newFolderId = folderIdMap[s.folderId] || null;
            }
          }
        }
        // Import stars
        if (Array.isArray(imported.stars)) {
          for (const s of imported.stars) {
            if (s.name && s.x !== undefined && s.y !== undefined && s.z !== undefined) {
              // Support old zoneId (single) and new zoneIds (array)
              let zoneIds = [];
              if (s.zoneIds && Array.isArray(s.zoneIds)) {
                zoneIds = s.zoneIds.map(zid => zoneIdMap[zid]).filter(Boolean);
              } else if (s.zoneId) {
                const mapped = zoneIdMap[s.zoneId];
                if (mapped) zoneIds = [mapped];
              }
              const star = { id: nextStarId++, name: s.name, x: parseFloat(s.x), y: parseFloat(s.y), z: parseFloat(s.z), zoneIds, size: parseFloat(s.size) || DEFAULT_STAR_SIZE, folderId: s._newFolderId || s.folderId || null };
              starIdMap[s.id] = star.id;
              stars.push(star);
              for (const zid of zoneIds) {
                const zone = zones.find(z => z.id === zid);
                if (zone && !zone.starIds.includes(star.id)) zone.starIds.push(star.id);
              }
            }
          }
        }
        // Import planets
        const planetIdMap = {};
        if (imported.planets && Array.isArray(imported.planets)) {
          for (const p of imported.planets) {
            if (p.name && p.starId !== undefined && p.orbitalRadius !== undefined) {
              const newStarId = starIdMap[p.starId];
              if (newStarId) {
                const defaultSize = (PLANET_CLASSIFICATIONS[p.classification] || PLANET_CLASSIFICATIONS.terrestrial).defaultSize;
                const planet = { id: nextPlanetId++, name: p.name, starId: newStarId, orbitalRadius: parseFloat(p.orbitalRadius), orbitalAngle: parseFloat(p.orbitalAngle || 0), classification: p.classification || 'terrestrial', size: parseFloat(p.size) || defaultSize };
                planetIdMap[p.id] = planet.id;
                planets.push(planet);
              }
            }
          }
        }
        // Import moons
        if (imported.moons && Array.isArray(imported.moons)) {
          for (const m of imported.moons) {
            if (m.name && m.planetId !== undefined && m.orbitalRadius !== undefined) {
              const newPlanetId = planetIdMap[m.planetId];
              if (newPlanetId) {
                const moon = { id: nextMoonId++, name: m.name, planetId: newPlanetId, orbitalRadius: parseFloat(m.orbitalRadius), orbitalAngle: parseFloat(m.orbitalAngle || 0), size: parseFloat(m.size) || DEFAULT_MOON_SIZE };
                moons.push(moon);
              }
            }
          }
        }
      }

      // Rebuild everything once
      rebuildStarMeshes();
      rebuildPlanetMeshes();
      rebuildZoneMeshes();
      autoAssignStarsToZones();
      updateStarList();
      updateZoneList();
      updateZoneDropdowns();
      saveToLocalStorage();
    } catch (err) {
      alert('Invalid JSON file: ' + err.message);
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

document.getElementById('btn-clear-all').addEventListener('click', () => {
  if (stars.length || zones.length || planets.length || moons.length) {
    if (confirm('Export a save before clearing?')) {
      document.getElementById('btn-export').click();
    }
  }
  if (!confirm('Delete all stars, planets, moons, and zones?')) return;
  stars = [];
  zones = [];
  planets = [];
  moons = [];
  starFolders = [];
  nextStarId = 1;
  nextZoneId = 1;
  nextPlanetId = 1;
  nextMoonId = 1;
  nextFolderId = 1;
  measureSelection = [];
  clearMeasureLine();
  rebuildStarMeshes();
  rebuildPlanetMeshes();
  rebuildZoneMeshes();
  updateStarList();
  updateZoneList();
  updateZoneDropdowns();
  saveToLocalStorage();
});

// ── LocalStorage ─────────────────────────────────────
function saveToLocalStorage() {
  localStorage.setItem('universe-map-stars', JSON.stringify(stars));
  localStorage.setItem('universe-map-zones', JSON.stringify(zones));
  localStorage.setItem('universe-map-planets', JSON.stringify(planets));
  localStorage.setItem('universe-map-moons', JSON.stringify(moons));
  localStorage.setItem('universe-map-starFolders', JSON.stringify(starFolders));
  localStorage.setItem('universe-map-nextStarId', nextStarId);
  localStorage.setItem('universe-map-nextZoneId', nextZoneId);
  localStorage.setItem('universe-map-nextPlanetId', nextPlanetId);
  localStorage.setItem('universe-map-nextMoonId', nextMoonId);
  localStorage.setItem('universe-map-nextFolderId', nextFolderId);
}

function loadFromLocalStorage() {
  try {
    const starData = localStorage.getItem('universe-map-stars');
    const zoneData = localStorage.getItem('universe-map-zones');
    const planetData = localStorage.getItem('universe-map-planets');
    const moonData = localStorage.getItem('universe-map-moons');
    const folderData = localStorage.getItem('universe-map-starFolders');
    const nsid = localStorage.getItem('universe-map-nextStarId');
    const nzid = localStorage.getItem('universe-map-nextZoneId');
    const npid = localStorage.getItem('universe-map-nextPlanetId');
    const nmid = localStorage.getItem('universe-map-nextMoonId');
    const nfid = localStorage.getItem('universe-map-nextFolderId');

    if (zoneData) {
      zones = JSON.parse(zoneData);
      nextZoneId = nzid ? parseInt(nzid) : (zones.length ? Math.max(...zones.map(z => z.id)) + 1 : 1);
    }
    if (starData) {
      stars = JSON.parse(starData);
      // Migrate old zoneId (single) to zoneIds (array)
      for (const s of stars) {
        if (!s.zoneIds) {
          s.zoneIds = s.zoneId ? [s.zoneId] : [];
          delete s.zoneId;
        }
      }
      nextStarId = nsid ? parseInt(nsid) : (stars.length ? Math.max(...stars.map(s => s.id)) + 1 : 1);
    }
    if (planetData) {
      planets = JSON.parse(planetData);
      nextPlanetId = npid ? parseInt(npid) : (planets.length ? Math.max(...planets.map(p => p.id)) + 1 : 1);
    }
    if (moonData) {
      moons = JSON.parse(moonData);
      nextMoonId = nmid ? parseInt(nmid) : (moons.length ? Math.max(...moons.map(m => m.id)) + 1 : 1);
    }
    if (folderData) {
      starFolders = JSON.parse(folderData);
      nextFolderId = nfid ? parseInt(nfid) : (starFolders.length ? Math.max(...starFolders.map(f => f.id)) + 1 : 1);
    }

    rebuildStarMeshes();
    rebuildPlanetMeshes();
    rebuildZoneMeshes();
    autoAssignStarsToZones();
    updateStarList();
    updateZoneList();
    updateZoneDropdowns();
  } catch (e) {
    console.warn('Failed to load from localStorage', e);
  }
}
loadFromLocalStorage();

// ── Background Stars (cosmetic) ──────────────────────
function addBackgroundStars() {
  const count = 2000;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  for (let i = 0; i < count * 3; i++) {
    positions[i] = (Math.random() - 0.5) * lyToWorld(6000) + WORLD_SIZE / 2;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({ color: 0x334466, size: 2, transparent: true, opacity: 0.6 });
  scene.add(new THREE.Points(geo, mat));
}
addBackgroundStars();

// ── Animation Loop ───────────────────────────────────
// Convert a screen-pixel size to world units at a given distance from camera
function screenToWorld(screenPx, distance) {
  const vFov = camera.fov * Math.PI / 180;
  const worldPerPx = (2 * distance * Math.tan(vFov / 2)) / renderer.domElement.clientHeight;
  return screenPx * worldPerPx;
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();

  // Adaptive camera: adjust near clipping plane based on zoom level
  const camDist = camera.position.distanceTo(controls.target);
  camera.near = Math.max(0.001, camDist * 0.001);
  camera.far = Math.max(500000, camDist * 100);
  camera.updateProjectionMatrix();

  // Dynamically size star sprites and name labels relative to viewport
  for (let i = 0; i < starGroup.children.length; i++) {
    const starSprite = starGroup.children[i];
    const dist = camera.position.distanceTo(starSprite.position);
    const s = Math.max(screenToWorld(STAR_SCREEN_SIZE, dist), STAR_MIN_WORLD);
    starSprite.scale.set(s, s, 1);

    const label = nameSprites.children[i];
    if (label) {
      if (dist > STAR_LABEL_VISIBLE_DIST) {
        label.visible = false;
      } else {
        label.visible = true;
        const lw = screenToWorld(LABEL_SCREEN_WIDTH, dist);
        const lh = screenToWorld(LABEL_SCREEN_HEIGHT, dist);
        // Fade in as camera approaches
        const fadeStart = STAR_LABEL_VISIBLE_DIST;
        const fadeEnd = STAR_LABEL_VISIBLE_DIST - STAR_LABEL_FADE_DIST;
        const opacity = dist <= fadeEnd ? 1 : 1 - (dist - fadeEnd) / STAR_LABEL_FADE_DIST;
        label.material.opacity = opacity;
        label.scale.set(lw, lh, 1);
        label.position.set(
          starSprite.position.x,
          starSprite.position.y + s * 0.6 + lh * 0.5,
          starSprite.position.z
        );
      }
    }
  }

  // Dynamically size zone labels
  for (const child of zoneGroup.children) {
    if (child.userData.isZoneLabel) {
      const dist = camera.position.distanceTo(child.position);
      const lw = screenToWorld(ZONE_LABEL_SCREEN_WIDTH, dist);
      const lh = screenToWorld(ZONE_LABEL_SCREEN_HEIGHT, dist);
      child.scale.set(lw, lh, 1);
      child.position.y = child.userData.anchorY + lh * 0.8;
    }
  }

  // Dynamically size measure label
  if (measureLabel && measureLabel.userData.isMeasureLabel) {
    const dist = camera.position.distanceTo(measureLabel.position);
    const lw = screenToWorld(ZONE_LABEL_SCREEN_WIDTH, dist);
    const lh = screenToWorld(ZONE_LABEL_SCREEN_HEIGHT, dist);
    measureLabel.scale.set(lw, lh, 1);
  }

  // Selection rings around selected stars
  const selIds = Array.from(selectedStarIds);
  ensureSelectionRings(selIds.length);
  let ringIdx = 0;
  for (const id of selIds) {
    const starSprite = starGroup.children.find(c => c.userData.starId === id);
    const ring = selectionRingGroup.children[ringIdx];
    if (starSprite && ring) {
      ring.visible = true;
      ring.position.copy(starSprite.position);
      const ringSize = starSprite.scale.x * 3;
      ring.scale.set(ringSize, ringSize, 1);
    } else if (ring) {
      ring.visible = false;
    }
    ringIdx++;
  }
  // Hide unused rings
  for (let i = ringIdx; i < selectionRingGroup.children.length; i++) {
    selectionRingGroup.children[i].visible = false;
  }

  renderer.render(scene, camera);
}
animate();

// ── Resize Handler ───────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
